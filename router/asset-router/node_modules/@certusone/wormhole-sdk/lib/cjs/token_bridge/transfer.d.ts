/// <reference types="node" />
import { Commitment, Connection, PublicKeyInitData, Transaction as SolanaTransaction } from "@solana/web3.js";
import { MsgExecuteContract } from "@terra-money/terra.js";
import { MsgExecuteContractCompat as MsgExecuteContractInjective } from "@injectivelabs/sdk-ts";
import { Algodv2 } from "algosdk";
import { ethers, Overrides, PayableOverrides } from "ethers";
import { TransactionSignerPair } from "@certusone/wormhole-sdk/lib/cjs/algorand";
import { ChainId, ChainName } from "@certusone/wormhole-sdk/lib/cjs/utils";
import { Types } from "aptos";
import { FunctionCallOptions } from "near-api-js/lib/account";
import { Provider } from "near-api-js/lib/providers";
import { MsgExecuteContract as XplaMsgExecuteContract } from "@xpla/xpla.js";
export declare function getAllowanceEth(tokenBridgeAddress: string, tokenAddress: string, signer: ethers.Signer): Promise<ethers.BigNumber>;
export declare function approveEth(tokenBridgeAddress: string, tokenAddress: string, signer: ethers.Signer, amount: ethers.BigNumberish, overrides?: Overrides & {
    from?: string | Promise<string>;
}): Promise<ethers.ContractReceipt>;
export declare function transferFromEth(tokenBridgeAddress: string, signer: ethers.Signer, tokenAddress: string, amount: ethers.BigNumberish, recipientChain: ChainId | ChainName, recipientAddress: Uint8Array, relayerFee?: ethers.BigNumberish, overrides?: PayableOverrides & {
    from?: string | Promise<string>;
}, payload?: Uint8Array | null): Promise<ethers.ContractReceipt>;
export declare function transferFromEthNative(tokenBridgeAddress: string, signer: ethers.Signer, amount: ethers.BigNumberish, recipientChain: ChainId | ChainId, recipientAddress: Uint8Array, relayerFee?: ethers.BigNumberish, overrides?: PayableOverrides & {
    from?: string | Promise<string>;
}, payload?: Uint8Array | null): Promise<ethers.ContractReceipt>;
export declare function transferFromTerra(walletAddress: string, tokenBridgeAddress: string, tokenAddress: string, amount: string, recipientChain: ChainId | ChainName, recipientAddress: Uint8Array, relayerFee?: string, payload?: Uint8Array | null): Promise<MsgExecuteContract[]>;
/**
 * Creates the necessary messages to transfer an asset
 * @param walletAddress Address of the Inj wallet
 * @param tokenBridgeAddress Address of the token bridge contract
 * @param tokenAddress Address of the token being transferred
 * @param amount Amount of token to be transferred
 * @param recipientChain Destination chain
 * @param recipientAddress Destination wallet address
 * @param relayerFee Relayer fee
 * @param payload Optional payload
 * @returns Transfer messages to be sent on chain
 */
export declare function transferFromInjective(walletAddress: string, tokenBridgeAddress: string, tokenAddress: string, amount: string, recipientChain: ChainId | ChainName, recipientAddress: Uint8Array, relayerFee?: string, payload?: Uint8Array | null): Promise<MsgExecuteContractInjective[]>;
export declare function transferFromXpla(walletAddress: string, tokenBridgeAddress: string, tokenAddress: string, amount: string, recipientChain: ChainId | ChainName, recipientAddress: Uint8Array, relayerFee?: string, payload?: Uint8Array | null): XplaMsgExecuteContract[];
export declare function transferNativeSol(connection: Connection, bridgeAddress: PublicKeyInitData, tokenBridgeAddress: PublicKeyInitData, payerAddress: PublicKeyInitData, amount: bigint, targetAddress: Uint8Array | Buffer, targetChain: ChainId | ChainName, relayerFee?: bigint, payload?: Uint8Array | Buffer | null, commitment?: Commitment): Promise<SolanaTransaction>;
export declare function transferFromSolana(connection: Connection, bridgeAddress: PublicKeyInitData, tokenBridgeAddress: PublicKeyInitData, payerAddress: PublicKeyInitData, fromAddress: PublicKeyInitData, mintAddress: PublicKeyInitData, amount: bigint, targetAddress: Uint8Array | Buffer, targetChain: ChainId | ChainName, originAddress?: Uint8Array | Buffer, originChain?: ChainId | ChainName, fromOwnerAddress?: PublicKeyInitData, relayerFee?: bigint, payload?: Uint8Array | Buffer | null, commitment?: Commitment): Promise<SolanaTransaction>;
/**
 * Transfers an asset from Algorand to a receiver on another chain
 * @param client AlgodV2 client
 * @param tokenBridgeId Application ID of the token bridge
 * @param bridgeId Application ID of the core bridge
 * @param sender Sending account
 * @param assetId Asset index
 * @param qty Quantity to transfer
 * @param receiver Receiving account
 * @param chain Reeiving chain
 * @param fee Transfer fee
 * @param payload payload for payload3 transfers
 * @returns Sequence number of confirmation
 */
export declare function transferFromAlgorand(client: Algodv2, tokenBridgeId: bigint, bridgeId: bigint, senderAddr: string, assetId: bigint, qty: bigint, receiver: string, chain: ChainId | ChainName, fee: bigint, payload?: Uint8Array | null): Promise<TransactionSignerPair[]>;
export declare function transferTokenFromNear(provider: Provider, account: string, coreBridge: string, tokenBridge: string, assetId: string, qty: bigint, receiver: Uint8Array, chain: ChainId | ChainName, fee: bigint, payload?: string): Promise<FunctionCallOptions[]>;
export declare function transferNearFromNear(provider: Provider, coreBridge: string, tokenBridge: string, qty: bigint, receiver: Uint8Array, chain: ChainId | ChainName, fee: bigint, payload?: string): Promise<FunctionCallOptions>;
/**
 * Transfer an asset on Aptos to another chain.
 * @param tokenBridgeAddress Address of token bridge
 * @param fullyQualifiedType Full qualified type of asset to transfer
 * @param amount Amount to send to recipient
 * @param recipientChain Target chain
 * @param recipient Recipient's address on target chain
 * @param relayerFee Fee to pay relayer
 * @param payload Payload3 data, leave undefined for basic token transfers
 * @returns Transaction payload
 */
export declare function transferFromAptos(tokenBridgeAddress: string, fullyQualifiedType: string, amount: string, recipientChain: ChainId | ChainName, recipient: Uint8Array, relayerFee?: string, payload?: string): Types.EntryFunctionPayload;
