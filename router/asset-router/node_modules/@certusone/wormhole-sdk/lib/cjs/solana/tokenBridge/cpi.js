"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCompleteTransferWrappedWithPayloadCpiAccounts = exports.getCompleteTransferNativeWithPayloadCpiAccounts = exports.getTransferWrappedWithPayloadCpiAccounts = exports.getTransferNativeWithPayloadCpiAccounts = exports.getTokenBridgeDerivedAccounts = void 0;
var spl_token_1 = require("@solana/spl-token");
var web3_js_1 = require("@solana/web3.js");
var vaa_1 = require("../../vaa");
var wormhole_1 = require("../wormhole");
var accounts_1 = require("./accounts");
var instructions_1 = require("./instructions");
/**
 * Generate Token Bridge PDAs.
 *
 * @param cpiProgramId
 * @param tokenBridgeProgramId
 * @param wormholeProgramId
 * @returns
 */
function getTokenBridgeDerivedAccounts(cpiProgramId, tokenBridgeProgramId, wormholeProgramId) {
    var _a = wormhole_1.getWormholeDerivedAccounts(tokenBridgeProgramId, wormholeProgramId), tokenBridgeEmitter = _a.wormholeEmitter, wormholeBridge = _a.wormholeBridge, wormholeFeeCollector = _a.wormholeFeeCollector, tokenBridgeSequence = _a.wormholeSequence;
    return {
        tokenBridgeConfig: accounts_1.deriveTokenBridgeConfigKey(tokenBridgeProgramId),
        tokenBridgeAuthoritySigner: accounts_1.deriveAuthoritySignerKey(tokenBridgeProgramId),
        tokenBridgeCustodySigner: accounts_1.deriveCustodySignerKey(tokenBridgeProgramId),
        tokenBridgeMintAuthority: accounts_1.deriveMintAuthorityKey(tokenBridgeProgramId),
        tokenBridgeSender: accounts_1.deriveSenderAccountKey(cpiProgramId),
        tokenBridgeRedeemer: accounts_1.deriveRedeemerAccountKey(cpiProgramId),
        wormholeBridge: wormholeBridge,
        tokenBridgeEmitter: tokenBridgeEmitter,
        wormholeFeeCollector: wormholeFeeCollector,
        tokenBridgeSequence: tokenBridgeSequence,
    };
}
exports.getTokenBridgeDerivedAccounts = getTokenBridgeDerivedAccounts;
/**
 * Generate accounts needed to perform `transfer_wrapped_with_payload` instruction
 * as cross-program invocation.
 *
 * @param cpiProgramId
 * @param tokenBridgeProgramId
 * @param wormholeProgramId
 * @param payer
 * @param message
 * @param fromTokenAccount
 * @param mint
 * @returns
 */
function getTransferNativeWithPayloadCpiAccounts(cpiProgramId, tokenBridgeProgramId, wormholeProgramId, payer, message, fromTokenAccount, mint) {
    var accounts = instructions_1.getTransferNativeWithPayloadAccounts(tokenBridgeProgramId, wormholeProgramId, payer, message, fromTokenAccount, mint, cpiProgramId);
    return {
        payer: accounts.payer,
        tokenBridgeConfig: accounts.config,
        fromTokenAccount: accounts.from,
        mint: accounts.mint,
        tokenBridgeCustody: accounts.custody,
        tokenBridgeAuthoritySigner: accounts.authoritySigner,
        tokenBridgeCustodySigner: accounts.custodySigner,
        wormholeBridge: accounts.wormholeBridge,
        wormholeMessage: accounts.wormholeMessage,
        tokenBridgeEmitter: accounts.wormholeEmitter,
        tokenBridgeSequence: accounts.wormholeSequence,
        wormholeFeeCollector: accounts.wormholeFeeCollector,
        clock: accounts.clock,
        tokenBridgeSender: accounts.sender,
        rent: accounts.rent,
        systemProgram: accounts.systemProgram,
        tokenProgram: accounts.tokenProgram,
        wormholeProgram: accounts.wormholeProgram,
    };
}
exports.getTransferNativeWithPayloadCpiAccounts = getTransferNativeWithPayloadCpiAccounts;
/**
 * Generate accounts needed to perform `transfer_wrapped_with_payload` instruction
 * as cross-program invocation.
 *
 * @param cpiProgramId
 * @param tokenBridgeProgramId
 * @param wormholeProgramId
 * @param payer
 * @param message
 * @param fromTokenAccount
 * @param tokenChain
 * @param tokenAddress
 * @param [fromTokenAccountOwner]
 * @returns
 */
function getTransferWrappedWithPayloadCpiAccounts(cpiProgramId, tokenBridgeProgramId, wormholeProgramId, payer, message, fromTokenAccount, tokenChain, tokenAddress, fromTokenAccountOwner) {
    var accounts = instructions_1.getTransferWrappedWithPayloadAccounts(tokenBridgeProgramId, wormholeProgramId, payer, message, fromTokenAccount, fromTokenAccountOwner === undefined ? cpiProgramId : fromTokenAccountOwner, tokenChain, tokenAddress, cpiProgramId);
    return {
        payer: accounts.payer,
        tokenBridgeConfig: accounts.config,
        fromTokenAccount: accounts.from,
        fromTokenAccountOwner: accounts.fromOwner,
        tokenBridgeWrappedMint: accounts.mint,
        tokenBridgeWrappedMeta: accounts.wrappedMeta,
        tokenBridgeAuthoritySigner: accounts.authoritySigner,
        wormholeBridge: accounts.wormholeBridge,
        wormholeMessage: accounts.wormholeMessage,
        tokenBridgeEmitter: accounts.wormholeEmitter,
        tokenBridgeSequence: accounts.wormholeSequence,
        wormholeFeeCollector: accounts.wormholeFeeCollector,
        clock: accounts.clock,
        tokenBridgeSender: accounts.sender,
        rent: accounts.rent,
        systemProgram: accounts.systemProgram,
        tokenProgram: accounts.tokenProgram,
        wormholeProgram: accounts.wormholeProgram,
    };
}
exports.getTransferWrappedWithPayloadCpiAccounts = getTransferWrappedWithPayloadCpiAccounts;
/**
 * Generate accounts needed to perform `complete_native_with_payload` instruction
 * as cross-program invocation.
 *
 * Note: `toFeesTokenAccount` is the same as `toTokenAccount`. For your program,
 * you only need to pass your `toTokenAccount` into the complete transfer
 * instruction for the `toFeesTokenAccount`.
 *
 * @param tokenBridgeProgramId
 * @param wormholeProgramId
 * @param payer
 * @param vaa
 * @param toTokenAccount
 * @returns
 */
function getCompleteTransferNativeWithPayloadCpiAccounts(tokenBridgeProgramId, wormholeProgramId, payer, vaa, toTokenAccount) {
    var parsed = vaa_1.isBytes(vaa) ? vaa_1.parseTokenTransferVaa(vaa) : vaa;
    var mint = new web3_js_1.PublicKey(parsed.tokenAddress);
    var cpiProgramId = new web3_js_1.PublicKey(parsed.to);
    return {
        payer: new web3_js_1.PublicKey(payer),
        tokenBridgeConfig: accounts_1.deriveTokenBridgeConfigKey(tokenBridgeProgramId),
        vaa: wormhole_1.derivePostedVaaKey(wormholeProgramId, parsed.hash),
        tokenBridgeClaim: wormhole_1.deriveClaimKey(tokenBridgeProgramId, parsed.emitterAddress, parsed.emitterChain, parsed.sequence),
        tokenBridgeForeignEndpoint: accounts_1.deriveEndpointKey(tokenBridgeProgramId, parsed.emitterChain, parsed.emitterAddress),
        toTokenAccount: new web3_js_1.PublicKey(toTokenAccount),
        tokenBridgeRedeemer: accounts_1.deriveRedeemerAccountKey(cpiProgramId),
        toFeesTokenAccount: new web3_js_1.PublicKey(toTokenAccount),
        tokenBridgeCustody: accounts_1.deriveCustodyKey(tokenBridgeProgramId, mint),
        mint: mint,
        tokenBridgeCustodySigner: accounts_1.deriveCustodySignerKey(tokenBridgeProgramId),
        rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        systemProgram: web3_js_1.SystemProgram.programId,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        wormholeProgram: new web3_js_1.PublicKey(wormholeProgramId),
    };
}
exports.getCompleteTransferNativeWithPayloadCpiAccounts = getCompleteTransferNativeWithPayloadCpiAccounts;
/**
 * Generate accounts needed to perform `complete_wrapped_with_payload` instruction
 * as cross-program invocation.
 *
 * Note: `toFeesTokenAccount` is the same as `toTokenAccount`. For your program,
 * you only need to pass your `toTokenAccount` into the complete transfer
 * instruction for the `toFeesTokenAccount`.
 *
 * @param cpiProgramId
 * @param tokenBridgeProgramId
 * @param wormholeProgramId
 * @param payer
 * @param vaa
 * @returns
 */
function getCompleteTransferWrappedWithPayloadCpiAccounts(tokenBridgeProgramId, wormholeProgramId, payer, vaa, toTokenAccount) {
    var parsed = vaa_1.isBytes(vaa) ? vaa_1.parseTokenTransferVaa(vaa) : vaa;
    var mint = accounts_1.deriveWrappedMintKey(tokenBridgeProgramId, parsed.tokenChain, parsed.tokenAddress);
    var cpiProgramId = new web3_js_1.PublicKey(parsed.to);
    return {
        payer: new web3_js_1.PublicKey(payer),
        tokenBridgeConfig: accounts_1.deriveTokenBridgeConfigKey(tokenBridgeProgramId),
        vaa: wormhole_1.derivePostedVaaKey(wormholeProgramId, parsed.hash),
        tokenBridgeClaim: wormhole_1.deriveClaimKey(tokenBridgeProgramId, parsed.emitterAddress, parsed.emitterChain, parsed.sequence),
        tokenBridgeForeignEndpoint: accounts_1.deriveEndpointKey(tokenBridgeProgramId, parsed.emitterChain, parsed.emitterAddress),
        toTokenAccount: new web3_js_1.PublicKey(toTokenAccount),
        tokenBridgeRedeemer: accounts_1.deriveRedeemerAccountKey(cpiProgramId),
        toFeesTokenAccount: new web3_js_1.PublicKey(toTokenAccount),
        tokenBridgeWrappedMint: mint,
        tokenBridgeWrappedMeta: accounts_1.deriveWrappedMetaKey(tokenBridgeProgramId, mint),
        tokenBridgeMintAuthority: accounts_1.deriveMintAuthorityKey(tokenBridgeProgramId),
        rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        systemProgram: web3_js_1.SystemProgram.programId,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        wormholeProgram: new web3_js_1.PublicKey(wormholeProgramId),
    };
}
exports.getCompleteTransferWrappedWithPayloadCpiAccounts = getCompleteTransferWrappedWithPayloadCpiAccounts;
