"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTokenBridgeUpgradeContractVaa = exports.parseTokenBridgeUpgradeContractGovernancePayload = exports.parseTokenBridgeRegisterChainVaa = exports.parseTokenBridgeRegisterChainGovernancePayload = exports.parseAttestMetaVaa = exports.parseAttestMetaPayload = exports.parseTokenTransferVaa = exports.parseTokenTransferPayload = exports.TokenBridgeGovernanceAction = exports.TokenBridgePayload = void 0;
var anchor_1 = require("@project-serum/anchor");
var governance_1 = require("./governance");
var wormhole_1 = require("./wormhole");
var TokenBridgePayload;
(function (TokenBridgePayload) {
    TokenBridgePayload[TokenBridgePayload["Transfer"] = 1] = "Transfer";
    TokenBridgePayload[TokenBridgePayload["AttestMeta"] = 2] = "AttestMeta";
    TokenBridgePayload[TokenBridgePayload["TransferWithPayload"] = 3] = "TransferWithPayload";
})(TokenBridgePayload = exports.TokenBridgePayload || (exports.TokenBridgePayload = {}));
var TokenBridgeGovernanceAction;
(function (TokenBridgeGovernanceAction) {
    TokenBridgeGovernanceAction[TokenBridgeGovernanceAction["RegisterChain"] = 1] = "RegisterChain";
    TokenBridgeGovernanceAction[TokenBridgeGovernanceAction["UpgradeContract"] = 2] = "UpgradeContract";
})(TokenBridgeGovernanceAction = exports.TokenBridgeGovernanceAction || (exports.TokenBridgeGovernanceAction = {}));
function parseTokenTransferPayload(payload) {
    var payloadType = payload.readUInt8(0);
    if (payloadType != TokenBridgePayload.Transfer &&
        payloadType != TokenBridgePayload.TransferWithPayload) {
        throw new Error("not token bridge transfer VAA");
    }
    var amount = BigInt(new anchor_1.BN(payload.subarray(1, 33)).toString());
    var tokenAddress = payload.subarray(33, 65);
    var tokenChain = payload.readUInt16BE(65);
    var to = payload.subarray(67, 99);
    var toChain = payload.readUInt16BE(99);
    var fee = payloadType == 1
        ? BigInt(new anchor_1.BN(payload.subarray(101, 133)).toString())
        : null;
    var fromAddress = payloadType == 3 ? payload.subarray(101, 133) : null;
    var tokenTransferPayload = payload.subarray(133);
    return {
        payloadType: payloadType,
        amount: amount,
        tokenAddress: tokenAddress,
        tokenChain: tokenChain,
        to: to,
        toChain: toChain,
        fee: fee,
        fromAddress: fromAddress,
        tokenTransferPayload: tokenTransferPayload,
    };
}
exports.parseTokenTransferPayload = parseTokenTransferPayload;
function parseTokenTransferVaa(vaa) {
    var parsed = wormhole_1.parseVaa(vaa);
    return __assign(__assign({}, parsed), parseTokenTransferPayload(parsed.payload));
}
exports.parseTokenTransferVaa = parseTokenTransferVaa;
function parseAttestMetaPayload(payload) {
    var payloadType = payload.readUInt8(0);
    if (payloadType != TokenBridgePayload.AttestMeta) {
        throw new Error("not token bridge attest meta VAA");
    }
    var tokenAddress = payload.subarray(1, 33);
    var tokenChain = payload.readUInt16BE(33);
    var decimals = payload.readUInt8(35);
    var symbol = payload.subarray(36, 68).toString().replace(/\0/g, "");
    var name = payload.subarray(68, 100).toString().replace(/\0/g, "");
    return {
        payloadType: payloadType,
        tokenAddress: tokenAddress,
        tokenChain: tokenChain,
        decimals: decimals,
        symbol: symbol,
        name: name,
    };
}
exports.parseAttestMetaPayload = parseAttestMetaPayload;
function parseAttestMetaVaa(vaa) {
    var parsed = wormhole_1.parseVaa(vaa);
    return __assign(__assign({}, parsed), parseAttestMetaPayload(parsed.payload));
}
exports.parseAttestMetaVaa = parseAttestMetaVaa;
function parseTokenBridgeRegisterChainGovernancePayload(payload) {
    var foreignChain = payload.readUInt16BE(0);
    var foreignAddress = payload.subarray(2, 34);
    return {
        foreignChain: foreignChain,
        foreignAddress: foreignAddress,
    };
}
exports.parseTokenBridgeRegisterChainGovernancePayload = parseTokenBridgeRegisterChainGovernancePayload;
function parseTokenBridgeRegisterChainVaa(vaa) {
    var parsed = governance_1.parseGovernanceVaa(vaa);
    if (parsed.action != TokenBridgeGovernanceAction.RegisterChain) {
        throw new Error("parsed.action != TokenBridgeGovernanceAction.RegisterChain");
    }
    return __assign(__assign({}, parsed), parseTokenBridgeRegisterChainGovernancePayload(parsed.orderPayload));
}
exports.parseTokenBridgeRegisterChainVaa = parseTokenBridgeRegisterChainVaa;
function parseTokenBridgeUpgradeContractGovernancePayload(payload) {
    var newContract = payload.subarray(0, 32);
    return {
        newContract: newContract,
    };
}
exports.parseTokenBridgeUpgradeContractGovernancePayload = parseTokenBridgeUpgradeContractGovernancePayload;
function parseTokenBridgeUpgradeContractVaa(vaa) {
    var parsed = governance_1.parseGovernanceVaa(vaa);
    if (parsed.action != TokenBridgeGovernanceAction.UpgradeContract) {
        throw new Error("parsed.action != TokenBridgeGovernanceAction.UpgradeContract");
    }
    return __assign(__assign({}, parsed), parseTokenBridgeUpgradeContractGovernancePayload(parsed.orderPayload));
}
exports.parseTokenBridgeUpgradeContractVaa = parseTokenBridgeUpgradeContractVaa;
