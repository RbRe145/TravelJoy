import { PublicKey } from "@solana/web3.js";
var NftBridgeInstructionCoder = /** @class */ (function () {
    function NftBridgeInstructionCoder(_) {
    }
    NftBridgeInstructionCoder.prototype.encode = function (ixName, ix) {
        switch (ixName) {
            case "initialize": {
                return encodeInitialize(ix);
            }
            case "completeNative": {
                return encodeCompleteNative(ix);
            }
            case "completeWrapped": {
                return encodeCompleteWrapped(ix);
            }
            case "completeWrappedMeta": {
                return encodeCompleteWrappedMeta(ix);
            }
            case "transferWrapped": {
                return encodeTransferWrapped(ix);
            }
            case "transferNative": {
                return encodeTransferNative(ix);
            }
            case "registerChain": {
                return encodeRegisterChain(ix);
            }
            case "upgradeContract": {
                return encodeUpgradeContract(ix);
            }
            default: {
                throw new Error("Invalid instruction: " + ixName);
            }
        }
    };
    NftBridgeInstructionCoder.prototype.encodeState = function (_ixName, _ix) {
        throw new Error("NFT Bridge program does not have state");
    };
    return NftBridgeInstructionCoder;
}());
export { NftBridgeInstructionCoder };
/** Solitaire enum of existing the NFT Bridge's instructions.
 *
 * https://github.com/certusone/wormhole/blob/main/solana/modules/nft_bridge/program/src/lib.rs#L74
 */
export var NftBridgeInstruction;
(function (NftBridgeInstruction) {
    NftBridgeInstruction[NftBridgeInstruction["Initialize"] = 0] = "Initialize";
    NftBridgeInstruction[NftBridgeInstruction["CompleteNative"] = 1] = "CompleteNative";
    NftBridgeInstruction[NftBridgeInstruction["CompleteWrapped"] = 2] = "CompleteWrapped";
    NftBridgeInstruction[NftBridgeInstruction["CompleteWrappedMeta"] = 3] = "CompleteWrappedMeta";
    NftBridgeInstruction[NftBridgeInstruction["TransferWrapped"] = 4] = "TransferWrapped";
    NftBridgeInstruction[NftBridgeInstruction["TransferNative"] = 5] = "TransferNative";
    NftBridgeInstruction[NftBridgeInstruction["RegisterChain"] = 6] = "RegisterChain";
    NftBridgeInstruction[NftBridgeInstruction["UpgradeContract"] = 7] = "UpgradeContract";
})(NftBridgeInstruction || (NftBridgeInstruction = {}));
function encodeNftBridgeInstructionData(instructionType, data) {
    var dataLen = data === undefined ? 0 : data.length;
    var instructionData = Buffer.alloc(1 + dataLen);
    instructionData.writeUInt8(instructionType, 0);
    if (dataLen > 0) {
        instructionData.write(data.toString("hex"), 1, "hex");
    }
    return instructionData;
}
function encodeInitialize(_a) {
    var wormhole = _a.wormhole;
    var serialized = Buffer.alloc(32);
    serialized.write(new PublicKey(wormhole).toBuffer().toString("hex"), 0, "hex");
    return encodeNftBridgeInstructionData(NftBridgeInstruction.Initialize, serialized);
}
function encodeCompleteNative(_a) {
    return encodeNftBridgeInstructionData(NftBridgeInstruction.CompleteNative);
}
function encodeCompleteWrapped(_a) {
    return encodeNftBridgeInstructionData(NftBridgeInstruction.CompleteWrapped);
}
function encodeCompleteWrappedMeta(_a) {
    return encodeNftBridgeInstructionData(NftBridgeInstruction.CompleteWrappedMeta);
}
function encodeTransferData(_a) {
    var nonce = _a.nonce, targetAddress = _a.targetAddress, targetChain = _a.targetChain;
    if (!Buffer.isBuffer(targetAddress)) {
        throw new Error("targetAddress must be Buffer");
    }
    var serialized = Buffer.alloc(38);
    serialized.writeUInt32LE(nonce, 0);
    serialized.write(targetAddress.toString("hex"), 4, "hex");
    serialized.writeUInt16LE(targetChain, 36);
    return serialized;
}
function encodeTransferWrapped(_a) {
    var nonce = _a.nonce, targetAddress = _a.targetAddress, targetChain = _a.targetChain;
    return encodeNftBridgeInstructionData(NftBridgeInstruction.TransferWrapped, encodeTransferData({ nonce: nonce, targetAddress: targetAddress, targetChain: targetChain }));
}
function encodeTransferNative(_a) {
    var nonce = _a.nonce, targetAddress = _a.targetAddress, targetChain = _a.targetChain;
    return encodeNftBridgeInstructionData(NftBridgeInstruction.TransferNative, encodeTransferData({ nonce: nonce, targetAddress: targetAddress, targetChain: targetChain }));
}
function encodeRegisterChain(_a) {
    return encodeNftBridgeInstructionData(NftBridgeInstruction.RegisterChain);
}
function encodeUpgradeContract(_a) {
    return encodeNftBridgeInstructionData(NftBridgeInstruction.UpgradeContract);
}
