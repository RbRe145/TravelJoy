"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcalaJsonRpcProvider = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const providers_1 = require("@ethersproject/providers");
class AcalaJsonRpcProvider extends providers_1.JsonRpcProvider {
    constructor(url, network) {
        super(url, network);
    }
    /* ---------------
       override underlying _wrapTransaction to avoid tx hash check
       sendTransaction doesn't need it, just in case other methods call it
                                                           --------------- */
    _wrapTransaction(tx, hash, startBlock) {
        if (hash != null && (0, utils_1.hexDataLength)(hash) !== 32) {
            throw new Error('invalid response - sendTransaction');
        }
        const result = tx;
        // Check the hash we expect is the same as the hash the server reported
        if (hash != null && tx.hash !== hash) {
            // don't care ¯\_(ツ)_/¯
        }
        result.wait = async (confirms, timeout) => {
            if (confirms == null) {
                confirms = 1;
            }
            if (timeout == null) {
                timeout = 0;
            }
            // Get the details to detect replacement
            let replacement = undefined;
            if (confirms !== 0 && startBlock != null) {
                replacement = {
                    data: tx.data,
                    from: tx.from,
                    nonce: tx.nonce,
                    to: tx.to,
                    value: tx.value,
                    startBlock,
                };
            }
            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);
            if (receipt == null && confirms === 0) {
                return null;
            }
            // No longer pending, allow the polling loop to garbage collect this
            this._emitted['t:' + tx.hash] = receipt.blockNumber;
            if (receipt.status === 0) {
                ethers_1.logger.throwError('transaction failed', utils_1.Logger.errors.CALL_EXCEPTION, {
                    transactionHash: tx.hash,
                    transaction: tx,
                    receipt: receipt,
                });
            }
            return receipt;
        };
        return result;
    }
    // override the underlying _wrapTransaction to avoid tx replacement check
    async _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
        const receipt = await this.getTransactionReceipt(transactionHash);
        // Receipt is already good
        if ((receipt ? receipt.confirmations : 0) >= confirmations) {
            return receipt;
        }
        // Poll until the receipt is good...
        return new Promise((resolve, reject) => {
            const cancelFuncs = [];
            let done = false;
            const alreadyDone = function () {
                if (done) {
                    return true;
                }
                done = true;
                cancelFuncs.forEach((func) => { func(); });
                return false;
            };
            const minedHandler = (receipt) => {
                if (receipt.confirmations < confirmations) {
                    return;
                }
                if (alreadyDone()) {
                    return;
                }
                resolve(receipt);
            };
            this.on(transactionHash, minedHandler);
            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });
            if (replaceable) {
                // don't care ¯\_(ツ)_/¯
            }
            if (typeof (timeout) === 'number' && timeout > 0) {
                const timer = setTimeout(() => {
                    if (alreadyDone()) {
                        return;
                    }
                    reject(ethers_1.logger.makeError('timeout exceeded', utils_1.Logger.errors.TIMEOUT, { timeout: timeout }));
                }, timeout);
                if (timer.unref) {
                    timer.unref();
                }
                cancelFuncs.push(() => { clearTimeout(timer); });
            }
        });
    }
    async sendTransaction(signedTransaction) {
        await this.getNetwork();
        const hexTx = await Promise.resolve(signedTransaction).then(t => (0, utils_1.hexlify)(t));
        const tx = this.formatter.transaction(signedTransaction);
        if (tx.confirmations == null) {
            tx.confirmations = 0;
        }
        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        try {
            const realHash = await this.perform('sendTransaction', { signedTransaction: hexTx });
            tx.hash = realHash; // override the auto computed "wrong" hash with real one
            return this._wrapTransaction(tx, realHash, blockNumber);
        }
        catch (error) {
            error.transaction = tx;
            error.transactionHash = tx.hash;
            throw error;
        }
    }
}
exports.AcalaJsonRpcProvider = AcalaJsonRpcProvider;
