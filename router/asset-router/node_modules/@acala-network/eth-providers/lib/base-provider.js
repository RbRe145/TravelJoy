"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _BaseProvider_subscription, _BaseProvider_async, _BaseProvider_headTasks, _BaseProvider_finalizedHeadTasks;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseProvider = exports.PollFilterType = exports.SubscriptionType = void 0;
const abstract_provider_1 = require("@ethersproject/abstract-provider");
const eth_transactions_1 = require("@acala-network/eth-transactions");
const utils_1 = require("ethers/lib/utils");
const AsyncAction_1 = require("rxjs/internal/scheduler/AsyncAction");
const AsyncScheduler_1 = require("rxjs/internal/scheduler/AsyncScheduler");
const ethers_1 = require("ethers");
const properties_1 = require("@ethersproject/properties");
const providers_1 = require("@ethersproject/providers");
const logger_1 = require("@ethersproject/logger");
const rxjs_1 = require("rxjs");
const types_1 = require("@polkadot/types");
const api_derive_1 = require("@polkadot/api-derive");
const operators_1 = require("rxjs/operators");
const address_1 = require("@ethersproject/address");
const bytes_1 = require("@ethersproject/bytes");
const util_1 = require("@polkadot/util");
const bn_js_1 = __importDefault(require("bn.js"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const consts_1 = require("./consts");
const utils_2 = require("./utils");
const BlockCache_1 = require("./utils/BlockCache");
const MaxSizeSet_1 = require("./utils/MaxSizeSet");
const subqlProvider_1 = require("./utils/subqlProvider");
/* ---------- subscriptions ---------- */
var SubscriptionType;
(function (SubscriptionType) {
    SubscriptionType["NewHeads"] = "newHeads";
    SubscriptionType["NewFinalizedHeads"] = "newFinalizedHeads";
    SubscriptionType["Logs"] = "logs";
})(SubscriptionType = exports.SubscriptionType || (exports.SubscriptionType = {}));
/* ---------- filters ---------- */
var PollFilterType;
(function (PollFilterType) {
    PollFilterType["NewBlocks"] = "newBlocks";
    PollFilterType["Logs"] = "logs";
})(PollFilterType = exports.PollFilterType || (exports.PollFilterType = {}));
class BaseProvider extends abstract_provider_1.Provider {
    constructor({ safeMode = false, localMode = false, verbose = false, maxBlockCacheSize = 200, storageCacheSize = 5000, subqlUrl, } = {}) {
        super();
        this.storages = new WeakMap();
        _BaseProvider_subscription.set(this, void 0);
        this.best$ = new rxjs_1.ReplaySubject(1);
        this.finalized$ = new rxjs_1.ReplaySubject(1);
        _BaseProvider_async.set(this, new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction));
        _BaseProvider_headTasks.set(this, new Map());
        _BaseProvider_finalizedHeadTasks.set(this, new Map());
        this.startSubscriptions = async () => {
            this.head$ = this.api.rx.rpc.chain.subscribeNewHeads();
            this.finalizedHead$ = this.api.rx.rpc.chain.subscribeFinalizedHeads();
            const headSub = this.head$.subscribe(header => {
                this.best$.next({ hash: header.hash.toHex(), number: header.number.toNumber() });
            });
            const finalizedSub = this.finalizedHead$.subscribe(header => {
                this.finalizedBlockHashes.add(header.hash.toHex());
                this.finalized$.next({ hash: header.hash.toHex(), number: header.number.toNumber() });
            });
            await (0, rxjs_1.firstValueFrom)(this.head$);
            await (0, rxjs_1.firstValueFrom)(this.finalizedHead$);
            const safeHead$ = this.safeMode
                ? this.finalizedHead$
                : this.head$;
            const headTasksSub = safeHead$.pipe(
            // no reciepts for genesis block
            (0, operators_1.filter)(header => header.number.toNumber() > 0)).subscribe(header => {
                const task = __classPrivateFieldGet(this, _BaseProvider_async, "f").schedule(this._onNewHead, 0, [header, 5]);
                __classPrivateFieldGet(this, _BaseProvider_headTasks, "f").set(header.hash.toHex(), task);
            });
            const finalizedTasksSub = this.finalizedHead$.pipe((0, operators_1.filter)(header => header.number.toNumber() > 0)).subscribe(header => {
                // notify subscribers
                const task = __classPrivateFieldGet(this, _BaseProvider_async, "f").schedule(this._onNewFinalizedHead, 0, [header, 5]);
                __classPrivateFieldGet(this, _BaseProvider_finalizedHeadTasks, "f").set(header.hash.toHex(), task);
            });
            return () => {
                headSub.unsubscribe();
                finalizedSub.unsubscribe();
                headTasksSub.unsubscribe();
                finalizedTasksSub.unsubscribe();
            };
        };
        this._onNewHead = async ([header, attempts]) => {
            attempts--;
            const blockHash = header.hash.toHex();
            try {
                const receipts = await (0, utils_2.getAllReceiptsAtBlock)(this.api, blockHash);
                // update block cache
                this.blockCache.addReceipts(blockHash, receipts);
                // eth_subscribe
                await this._notifySubscribers(header, receipts);
                __classPrivateFieldGet(this, _BaseProvider_headTasks, "f").get(blockHash)?.unsubscribe();
                __classPrivateFieldGet(this, _BaseProvider_headTasks, "f").delete(blockHash);
            }
            catch (e) {
                if (attempts) {
                    // reschedule after 1s
                    const task = __classPrivateFieldGet(this, _BaseProvider_async, "f").schedule(this._onNewHead, 1000, [header, attempts]);
                    __classPrivateFieldGet(this, _BaseProvider_headTasks, "f").get(blockHash)?.unsubscribe();
                    __classPrivateFieldGet(this, _BaseProvider_headTasks, "f").set(blockHash, task);
                }
                else {
                    console.log('_onNewHead task failed, give up', blockHash, e.toString());
                }
            }
        };
        this._onNewFinalizedHead = async ([header, attempts]) => {
            attempts--;
            const blockHash = header.hash.toHex();
            try {
                const block = await this.getBlockDataForHeader(header, false);
                const response = (0, utils_2.hexlifyRpcResult)(block);
                this.eventListeners[SubscriptionType.NewFinalizedHeads].forEach((l) => l.cb(response));
                __classPrivateFieldGet(this, _BaseProvider_finalizedHeadTasks, "f").get(blockHash)?.unsubscribe();
                __classPrivateFieldGet(this, _BaseProvider_finalizedHeadTasks, "f").delete(blockHash);
            }
            catch (e) {
                if (attempts) {
                    // reschedule after 1s
                    const task = __classPrivateFieldGet(this, _BaseProvider_async, "f").schedule(this._onNewFinalizedHead, 1000, [header, attempts]);
                    __classPrivateFieldGet(this, _BaseProvider_finalizedHeadTasks, "f").get(blockHash)?.unsubscribe();
                    __classPrivateFieldGet(this, _BaseProvider_finalizedHeadTasks, "f").set(blockHash, task);
                }
                else {
                    console.log('_onNewFinalizedHead task failed, give up', blockHash, e.toString());
                }
            }
        };
        this._notifySubscribers = async (header, receipts) => {
            const headSubscribers = this.eventListeners[SubscriptionType.NewHeads];
            const logSubscribers = this.eventListeners[SubscriptionType.Logs];
            if (headSubscribers.length > 0 || logSubscribers.length > 0) {
                const block = await this.getBlockDataForHeader(header, false);
                const response = (0, utils_2.hexlifyRpcResult)(block);
                headSubscribers.forEach((l) => l.cb(response));
                if (logSubscribers.length > 0) {
                    const logs = receipts.map((r) => r.logs).flat();
                    logSubscribers.forEach(({ cb, filter }) => {
                        const filteredLogs = logs.filter((log) => (0, utils_2.filterLog)(log, filter));
                        (0, utils_2.hexlifyRpcResult)(filteredLogs).forEach(cb);
                    });
                }
            }
        };
        this.setApi = (api) => {
            (0, properties_1.defineReadOnly)(this, '_api', api);
        };
        this.queryStorage = async (module, args, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(await (0, utils_2.parseBlockTag)(_blockTag));
            const blockHash = await this._getBlockHash(blockTag);
            const registry = await this.api.getBlockRegistry((0, util_1.u8aToU8a)(blockHash));
            if (!this.storages.get(registry)) {
                const storage = (0, types_1.decorateStorage)(registry.registry, registry.metadata.asLatest, registry.metadata.version);
                this.storages.set(registry, storage);
            }
            const storage = this.storages.get(registry);
            const [section, method] = module.split('.');
            const entry = storage[section][method];
            const key = entry(...args);
            const outputType = (0, types_1.unwrapStorageType)(registry.registry, entry.meta.type, entry.meta.modifier.isOptional);
            const cacheKey = `${module}-${blockHash}-${args.join(',')}`;
            const cached = this.storageCache.get(cacheKey);
            let input = null;
            if (cached) {
                input = cached;
            }
            else {
                const value = await this.api.rpc.state.getStorage(key, blockHash);
                const isEmpty = (0, util_1.isNull)(value);
                // we convert to Uint8Array since it maps to the raw encoding, all
                // data will be correctly encoded (incl. numbers, excl. :code)
                input = isEmpty
                    ? null
                    : (0, util_1.u8aToU8a)(entry.meta.modifier.isOptional ? value.toU8a() : value.isSome ? value.unwrap().toU8a() : null);
                this.storageCache.set(cacheKey, input);
            }
            const result = registry.registry.createTypeUnsafe(outputType, [input], {
                blockHash,
                isPedantic: !entry.meta.modifier.isOptional,
            });
            return result;
        };
        this.isReady = async () => {
            try {
                await this.api.isReadyOrError;
                await this.getNetwork();
                if (!__classPrivateFieldGet(this, _BaseProvider_subscription, "f")) {
                    __classPrivateFieldSet(this, _BaseProvider_subscription, this.startSubscriptions(), "f");
                }
                // wait for subscription to happen
                await __classPrivateFieldGet(this, _BaseProvider_subscription, "f");
            }
            catch (e) {
                await this.api.disconnect();
                throw e;
            }
        };
        this.disconnect = async () => {
            this.eventListeners[SubscriptionType.NewHeads] = [];
            this.eventListeners[SubscriptionType.NewFinalizedHeads] = [];
            this.eventListeners[SubscriptionType.Logs] = [];
            __classPrivateFieldGet(this, _BaseProvider_subscription, "f") && (await __classPrivateFieldGet(this, _BaseProvider_subscription, "f"))();
            let attempts = 5;
            while (attempts) {
                attempts--;
                const pendingTasks = __classPrivateFieldGet(this, _BaseProvider_headTasks, "f").size + __classPrivateFieldGet(this, _BaseProvider_finalizedHeadTasks, "f").size;
                if (pendingTasks === 0)
                    break;
                // wait 1 second for all tasks to complete, then try again
                await new Promise(r => setTimeout(r, 1000));
                console.log(`disconnecting, waiting for ${pendingTasks} tasks to complete`);
            }
            await this.api.disconnect();
        };
        this.getNetwork = async () => {
            if (!this.network) {
                this.network = {
                    name: this.api.runtimeVersion.specName.toString(),
                    chainId: await this.chainId(),
                };
            }
            return this.network;
        };
        this.netVersion = async () => {
            return this.api.consts.evmAccounts.chainId.toString();
        };
        this.chainId = async () => {
            return this.api.consts.evmAccounts.chainId.toNumber();
        };
        this.getBlockNumber = async () => {
            return this.safeMode ? this.finalizedBlockNumber : this.bestBlockNumber;
        };
        this.getBlockData = async (_blockTag, full) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            const header = await this._getBlockHeader(blockTag);
            return this.getBlockDataForHeader(header, full);
        };
        this.getBlockDataForHeader = async (header, full) => {
            const blockHash = header.hash.toHex();
            const blockNumber = header.number.toNumber();
            const [block, validators, now, receiptsFromSubql] = await Promise.all([
                this.api.rpc.chain.getBlock(blockHash),
                this.api.query.session ? this.queryStorage('session.validators', [], blockHash) : [],
                this.queryStorage('timestamp.now', [], blockHash),
                this.subql?.getAllReceiptsAtBlock(blockHash),
            ]);
            const headerExtended = (0, api_derive_1.createHeaderExtended)(header.registry, header, validators);
            // blockscout need `toLowerCase`
            const author = headerExtended.author
                ? (await this.getEvmAddress(headerExtended.author.toString())).toLowerCase()
                : consts_1.DUMMY_ADDRESS;
            let receipts;
            if (receiptsFromSubql?.length) {
                receipts = receiptsFromSubql.map(utils_2.subqlReceiptAdapter);
            }
            else {
                /* ----------
                   if nothing is returned from subql, either no tx exists in this block,
                   or the block not finalized. So we still need to ask block cache.
                                                                              ---------- */
                receipts = this.blockCache.getAllReceiptsAtBlock(blockHash);
            }
            const transactions = full
                ? receipts.map((tx) => (0, utils_2.receiptToTransaction)(tx, block))
                : receipts.map((tx) => tx.transactionHash);
            const gasUsed = receipts.reduce((totalGas, tx) => totalGas.add(tx.gasUsed), consts_1.BIGNUMBER_ZERO);
            return {
                hash: blockHash,
                parentHash: headerExtended.parentHash.toHex(),
                number: blockNumber,
                stateRoot: headerExtended.stateRoot.toHex(),
                transactionsRoot: headerExtended.extrinsicsRoot.toHex(),
                timestamp: Math.floor(now.toNumber() / 1000),
                nonce: consts_1.DUMMY_BLOCK_NONCE,
                mixHash: consts_1.ZERO_BLOCK_HASH,
                difficulty: consts_1.ZERO,
                totalDifficulty: consts_1.ZERO,
                gasLimit: ethers_1.BigNumber.from(consts_1.BLOCK_GAS_LIMIT),
                gasUsed,
                miner: author,
                extraData: consts_1.EMPTY_HEX_STRING,
                sha3Uncles: consts_1.EMTPY_UNCLE_HASH,
                receiptsRoot: headerExtended.extrinsicsRoot.toHex(),
                logsBloom: consts_1.DUMMY_LOGS_BLOOM,
                size: block.encodedLength,
                uncles: consts_1.EMTPY_UNCLES,
                transactions,
            };
        };
        this.getBlock = async (_blockHashOrBlockTag) => (0, utils_2.throwNotImplemented)('getBlock (please use `getBlockData` instead)');
        this.getBlockWithTransactions = async (_blockHashOrBlockTag) => (0, utils_2.throwNotImplemented)('getBlockWithTransactions (please use `getBlockData` instead)');
        this.getBalance = async (addressOrName, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(await (0, utils_2.parseBlockTag)(_blockTag));
            const [address, blockHash] = await Promise.all([
                this._getAddress(addressOrName),
                this._getBlockHash(blockTag),
            ]);
            const substrateAddress = await this.getSubstrateAddress(address, blockHash);
            const accountInfo = await this.queryStorage('system.account', [substrateAddress], blockHash);
            return (0, utils_2.nativeToEthDecimal)(accountInfo.data.free.toBigInt());
        };
        this.getTransactionCount = async (addressOrName, blockTag) => {
            return this.getEvmTransactionCount(addressOrName, await (0, utils_2.parseBlockTag)(blockTag));
        };
        // TODO: test pending
        this.getEvmTransactionCount = async (addressOrName, blockTag) => {
            let pendingNonce = 0;
            if ((await blockTag) === 'pending') {
                const [substrateAddress, pendingExtrinsics] = await Promise.all([
                    this.getSubstrateAddress(await addressOrName),
                    this.api.rpc.author.pendingExtrinsics(),
                ]);
                pendingNonce = pendingExtrinsics.filter((e) => (0, utils_2.isEvmExtrinsic)(e) && e.signer.toString() === substrateAddress).length;
            }
            const accountInfo = await this.queryAccountInfo(addressOrName, blockTag);
            const minedNonce = accountInfo.isNone ? 0 : accountInfo.unwrap().nonce.toNumber();
            return minedNonce + pendingNonce;
        };
        this.getSubstrateNonce = async (addressOrName, blockTag) => {
            const resolvedBlockTag = await blockTag;
            const address = await this._getAddress(addressOrName);
            const [substrateAddress, blockHash] = await Promise.all([
                this.getSubstrateAddress(address),
                this._getBlockHash(blockTag),
            ]);
            if (resolvedBlockTag === 'pending') {
                const idx = await this.api.rpc.system.accountNextIndex(substrateAddress);
                return idx.toNumber();
            }
            const accountInfo = await this.queryStorage('system.account', [substrateAddress], blockHash);
            return accountInfo.nonce.toNumber();
        };
        this.getCode = async (addressOrName, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(await (0, utils_2.parseBlockTag)(_blockTag));
            if (blockTag === 'pending')
                return '0x';
            const [address, blockHash] = await Promise.all([
                this._getAddress(addressOrName),
                this._getBlockHash(blockTag),
            ]);
            const contractInfo = await this.queryContractInfo(address, blockHash);
            if (contractInfo.isNone) {
                return '0x';
            }
            const codeHash = contractInfo.unwrap().codeHash;
            const api = blockHash ? await this.api.at(blockHash) : this.api;
            const code = await api.query.evm.codes(codeHash);
            return code.toHex();
        };
        // TODO: removable?
        this.call = async (_transaction, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(await (0, utils_2.parseBlockTag)(_blockTag));
            const [txRequest, blockHash] = await Promise.all([
                (0, utils_2.getTransactionRequest)(_transaction),
                this._getBlockHash(blockTag),
            ]);
            const transaction = txRequest.gasLimit && txRequest.gasPrice
                ? txRequest
                : { ...txRequest, ...(await this._getEthGas()) };
            const { storageLimit, gasLimit } = this._getSubstrateGasParams(transaction);
            const callRequest = {
                from: transaction.from,
                to: transaction.to,
                gasLimit,
                storageLimit,
                value: transaction.value?.toBigInt(),
                data: transaction.data,
                accessList: transaction.accessList,
            };
            const res = await this._ethCall(callRequest, blockHash);
            return res.value;
        };
        this._ethCall = async (callRequest, at) => {
            const api = at ? await this.api.at(at) : this.api;
            const { from, to, gasLimit, storageLimit, value, data, accessList } = callRequest;
            const estimate = true;
            const res = to
                ? await api.call.evmRuntimeRPCApi.call(from, to, data, value, gasLimit, storageLimit, accessList, estimate)
                : await api.call.evmRuntimeRPCApi.create(from, data, value, gasLimit, storageLimit, accessList, estimate);
            const { ok, err } = res.toJSON();
            if (!ok) {
                // substrate level error
                const errMetaValid = err?.module.index !== undefined && err?.module.error !== undefined;
                if (!errMetaValid) {
                    return utils_2.logger.throwError('internal JSON-RPC error [unknown error - cannot decode error info from error meta]', logger_1.Logger.errors.CALL_EXCEPTION, callRequest);
                }
                const errInfo = this.api.registry.findMetaError({
                    index: new bn_js_1.default(err.module.index),
                    error: new bn_js_1.default((0, util_1.hexToU8a)(err.module.error)[0]),
                });
                const msg = `internal JSON-RPC error [${errInfo.section}.${errInfo.name}: ${errInfo.docs}]`;
                return utils_2.logger.throwError(msg, logger_1.Logger.errors.CALL_EXCEPTION, callRequest);
            }
            // check evm level error
            (0, utils_2.checkEvmExecutionError)(ok);
            return ok;
        };
        this.getStorageAt = async (addressOrName, position, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(await (0, utils_2.parseBlockTag)(_blockTag));
            const [address, blockHash, resolvedPosition] = await Promise.all([
                this._getAddress(addressOrName),
                this._getBlockHash(blockTag),
                Promise.resolve(position).then(bytes_1.hexValue),
            ]);
            const code = await this.queryStorage('evm.accountStorages', [address, (0, bytes_1.hexZeroPad)(resolvedPosition, 32)], blockHash);
            return code.toHex();
        };
        // @TODO
        this.resolveName = async (name) => {
            name = await name;
            return name;
            // If it is already an address, nothing to resolve
            // try {
            //   return Promise.resolve(this.formatter.address(name));
            // } catch (error) {
            //   // If is is a hexstring, the address is bad (See #694)
            //   if (isHexString(name)) {
            //     throw error;
            //   }
            // }
            // if (typeof name !== 'string') {
            //   logger.throwArgumentError('invalid ENS name', 'name', name);
            // }
            // // Get the addr from the resovler
            // const resolver = await this.getResolver(name);
            // if (!resolver) {
            //   return null;
            // }
            // return resolver.getAddress();
        };
        this.getGasPrice = async (validBlocks = 200) => {
            return ethers_1.BigNumber.from(consts_1.ONE_HUNDRED_GWEI).add(await this.bestBlockNumber + validBlocks);
        };
        this.getFeeData = async () => {
            return {
                maxFeePerGas: null,
                maxPriorityFeePerGas: null,
                lastBaseFeePerGas: null,
                gasPrice: await this.getGasPrice(),
            };
        };
        this._getGasConsts = () => ({
            storageDepositPerByte: this.api.consts.evm.storageDepositPerByte.toBigInt(),
            txFeePerGas: this.api.consts.evm.txFeePerGas.toBigInt(),
        });
        /**
         * Estimate gas for a transaction.
         * @param transaction The transaction to estimate the gas of
         * @returns The estimated gas used by this transaction
         */
        this.estimateGas = async (transaction) => {
            const { usedGas, gasLimit, usedStorage } = await this.estimateResources(transaction);
            const tx = await (0, properties_1.resolveProperties)(transaction);
            const data = tx.data?.toString() ?? '0x';
            const createParams = [
                data,
                (0, utils_2.toBN)(ethers_1.BigNumber.from(tx.value ?? 0)),
                (0, utils_2.toBN)(gasLimit),
                (0, utils_2.toBN)(usedStorage.isNegative() ? 0 : usedStorage),
                (0, utils_1.accessListify)(tx.accessList ?? []),
            ];
            const callParams = [tx.to, ...createParams];
            const extrinsic = tx.to
                ? this.api.tx.evm.call(...callParams)
                : this.api.tx.evm.create(...createParams);
            let txFee = await this._estimateGasCost(extrinsic);
            txFee = txFee.mul(gasLimit).div(usedGas); // scale it to the same ratio when estimate passing gasLimit
            if (usedStorage.gt(0)) {
                const storageFee = usedStorage.mul(this._getGasConsts().storageDepositPerByte);
                txFee = txFee.add(storageFee);
            }
            const gasPrice = tx.gasPrice && ethers_1.BigNumber.from(tx.gasPrice).gt(0)
                ? ethers_1.BigNumber.from(tx.gasPrice)
                : await this.getGasPrice();
            const tokenTransferSelector = '0xa9059cbb'; // transfer(address,uint256)
            const isTokenTransfer = (0, bytes_1.hexlify)(await transaction.data ?? '0x').startsWith(tokenTransferSelector);
            return (0, utils_2.encodeGasLimit)(txFee, gasPrice, gasLimit, usedStorage, isTokenTransfer);
        };
        this._estimateGasCost = async (extrinsic) => {
            const u8a = extrinsic.toU8a();
            const apiAt = await this.api.at(await this.bestBlockHash);
            const lenIncreaseAfterSignature = 100; // approximate length increase after signature
            const feeDetails = await apiAt.call.transactionPaymentApi.queryFeeDetails(u8a, u8a.length + lenIncreaseAfterSignature);
            const { baseFee, lenFee, adjustedWeightFee } = feeDetails.inclusionFee.unwrap();
            const nativeTxFee = ethers_1.BigNumber.from(baseFee.toBigInt() +
                lenFee.toBigInt() +
                adjustedWeightFee.toBigInt());
            return (0, utils_2.nativeToEthDecimal)(nativeTxFee);
        };
        /**
         * Get the gas for eth transactions
         * @returns The gas used by eth transaction
         */
        this.getEthResources = async (transaction, { gasLimit, storageLimit, validUntil, } = {}) => {
            if (!gasLimit || !storageLimit) {
                const { gasLimit: gas, usedStorage: storage } = await this.estimateResources(transaction);
                gasLimit = gasLimit ?? gas;
                storageLimit = storageLimit ?? storage;
            }
            if (!validUntil) {
                const blockNumber = await this.getBlockNumber();
                // Expires after 100 blocks by default
                validUntil = blockNumber + 100;
            }
            const storageByteDeposit = this.api.consts.evm.storageDepositPerByte.toBigInt();
            const txFeePerGas = this.api.consts.evm.txFeePerGas.toBigInt();
            const { txGasLimit, txGasPrice } = (0, utils_2.calcEthereumTransactionParams)({
                gasLimit,
                storageLimit,
                validUntil,
                storageByteDeposit,
                txFeePerGas,
            });
            return {
                gasLimit: txGasLimit,
                gasPrice: txGasPrice,
            };
        };
        /**
         * helper to get ETH gas when don't know the whole transaction
         * default to return big enough gas for contract deployment
         * @returns The gas used by eth transaction
         */
        this._getEthGas = async ({ gasLimit = 21000000, storageLimit = 64100, validUntil: _validUntil, } = {}) => {
            const validUntil = _validUntil || (await this.getBlockNumber()) + 150; // default 150 * 12 / 60 = 30min
            const storageByteDeposit = this.api.consts.evm.storageDepositPerByte.toBigInt();
            const txFeePerGas = this.api.consts.evm.txFeePerGas.toBigInt();
            const { txGasLimit, txGasPrice } = (0, utils_2.calcEthereumTransactionParams)({
                gasLimit,
                storageLimit,
                validUntil,
                storageByteDeposit,
                txFeePerGas,
            });
            return {
                gasLimit: txGasLimit,
                gasPrice: txGasPrice,
            };
        };
        /**
         * Validate substrate transaction parameters
         */
        this.validSubstrateResources = ({ gasLimit, gasPrice, }) => {
            const storageByteDeposit = this.api.consts.evm.storageDepositPerByte.toBigInt();
            const txFeePerGas = this.api.consts.evm.txFeePerGas.toBigInt();
            return (0, utils_2.calcSubstrateTransactionParams)({
                txGasPrice: gasPrice,
                txGasLimit: gasLimit,
                storageByteDeposit,
                txFeePerGas,
            });
        };
        /**
         * Estimate resources for a transaction.
         * @param transaction The transaction to estimate the resources of
         * @returns The estimated resources used by this transaction
         */
        this.estimateResources = async (transaction) => {
            const MAX_GAS_LIMIT = consts_1.BLOCK_GAS_LIMIT * 10; // capped at 10x (1000%) the current block gas limit
            const MIN_GAS_LIMIT = 21000;
            const STORAGE_LIMIT = consts_1.BLOCK_STORAGE_LIMIT;
            const _txRequest = await (0, utils_2.getTransactionRequest)(transaction);
            const txRequest = {
                ..._txRequest,
                value: ethers_1.BigNumber.isBigNumber(_txRequest.value) ? _txRequest.value.toBigInt() : _txRequest.value,
                gasLimit: _txRequest.gasLimit?.toBigInt() || MAX_GAS_LIMIT,
                storageLimit: STORAGE_LIMIT,
            };
            const { used_gas: usedGas, used_storage: usedStorage } = await this._ethCall(txRequest);
            // binary search the best passing gasLimit
            let lowest = MIN_GAS_LIMIT;
            let highest = MAX_GAS_LIMIT;
            let mid = Math.min(usedGas * 3, Math.floor((lowest + highest) / 2));
            let prevHighest = highest;
            while (highest - lowest > 1) {
                try {
                    await this._ethCall({
                        ...txRequest,
                        gasLimit: mid,
                    });
                    highest = mid;
                    if ((prevHighest - highest) / prevHighest < 0.1)
                        break;
                    prevHighest = highest;
                }
                catch (e) {
                    if (e.message.includes('revert') || e.message.includes('outOfGas')) {
                        lowest = mid;
                    }
                    else {
                        throw e;
                    }
                }
                mid = Math.floor((highest + lowest) / 2);
            }
            return {
                usedGas: ethers_1.BigNumber.from(usedGas),
                gasLimit: ethers_1.BigNumber.from(highest),
                usedStorage: ethers_1.BigNumber.from(usedStorage),
            };
        };
        this.getSubstrateAddress = async (addressOrName, blockTag) => {
            const [address, blockHash] = await Promise.all([
                this._getAddress(addressOrName),
                this._getBlockHash(blockTag),
            ]);
            const substrateAccount = await this.queryStorage('evmAccounts.accounts', [address], blockHash);
            return substrateAccount.isEmpty ? (0, utils_2.computeDefaultSubstrateAddress)(address) : substrateAccount.toString();
        };
        this.getEvmAddress = async (substrateAddress, blockTag) => {
            const blockHash = await this._getBlockHash(blockTag);
            const evmAddress = await this.queryStorage('evmAccounts.evmAddresses', [substrateAddress], blockHash);
            return (0, address_1.getAddress)(evmAddress.isEmpty ? (0, utils_2.computeDefaultEvmAddress)(substrateAddress) : evmAddress.toString());
        };
        this.queryAccountInfo = async (addressOrName, _blockTag) => {
            let blockTag = await this._ensureSafeModeBlockTagFinalization(await (0, utils_2.parseBlockTag)(_blockTag));
            if (blockTag === 'pending') {
                blockTag = 'latest';
            }
            const [address, blockHash] = await Promise.all([
                this._getAddress(addressOrName),
                this._getBlockHash(blockTag),
            ]);
            const accountInfo = await this.queryStorage('evm.accounts', [address], blockHash);
            return accountInfo;
        };
        this.queryContractInfo = async (addressOrName, blockTag) => {
            const accountInfo = await this.queryAccountInfo(addressOrName, blockTag);
            if (accountInfo.isNone) {
                return this.api.createType('Option<EvmContractInfo>', null);
            }
            return accountInfo.unwrap().contractInfo;
        };
        this._getSubstrateGasParams = (ethTx) => {
            let gasLimit = 0n;
            let storageLimit = 0n;
            let validUntil = 0n;
            let tip = 0n;
            let v2 = false;
            if (ethTx.type === 96) {
                // EIP-712 transaction
                if (!ethTx.gasLimit)
                    return utils_2.logger.throwError('expect gasLimit');
                if (!ethTx.storageLimit)
                    return utils_2.logger.throwError('expect storageLimit');
                if (!ethTx.validUntil)
                    return utils_2.logger.throwError('expect validUntil');
                if (!ethTx.tip)
                    return utils_2.logger.throwError('expect priorityFee (tip)');
                gasLimit = ethTx.gasLimit.toBigInt();
                storageLimit = BigInt(ethTx.storageLimit.toString());
                validUntil = BigInt(ethTx.validUntil.toString());
                tip = BigInt(ethTx.tip.toString());
            }
            else if (ethTx.type === undefined || // legacy
                ethTx.type === null || // legacy
                ethTx.type === 0 // EIP-155
            ) {
                try {
                    const { storageDepositPerByte, txFeePerGas } = this._getGasConsts();
                    const params = (0, utils_2.calcSubstrateTransactionParams)({
                        txGasPrice: ethTx.maxFeePerGas || ethTx.gasPrice || '0',
                        txGasLimit: ethTx.gasLimit || '0',
                        storageByteDeposit: storageDepositPerByte,
                        txFeePerGas: txFeePerGas,
                    });
                    gasLimit = params.gasLimit.toBigInt();
                    validUntil = params.validUntil.toBigInt();
                    storageLimit = params.storageLimit.toBigInt();
                    tip = (ethTx.maxPriorityFeePerGas?.toBigInt() || 0n) * gasLimit;
                    if (gasLimit < 0n || validUntil < 0n || storageLimit < 0n) {
                        throw new Error();
                    }
                }
                catch (error) {
                    // v2
                    v2 = true;
                    if (!ethTx.gasLimit)
                        return utils_2.logger.throwError('expect gasLimit');
                    if (!ethTx.gasPrice)
                        return utils_2.logger.throwError('expect gasPrice');
                    const bbbcc = ethTx.gasLimit.mod(consts_1.GAS_MASK);
                    const encodedGasLimit = bbbcc.div(consts_1.STORAGE_MASK); // bbb
                    const encodedStorageLimit = bbbcc.mod(consts_1.STORAGE_MASK); // cc
                    let gasPrice = ethTx.gasPrice;
                    const tipNumber = gasPrice.div(consts_1.TEN_GWEI).sub(10);
                    if (tipNumber.gt(0)) {
                        gasPrice = gasPrice.sub(tipNumber.mul(consts_1.TEN_GWEI));
                        const ethTip = gasPrice.mul(ethTx.gasLimit).mul(tipNumber).div(10);
                        tip = (0, utils_2.ethToNativeDecimal)(ethTip).toBigInt();
                    }
                    validUntil = gasPrice.sub(consts_1.ONE_HUNDRED_GWEI).toBigInt();
                    if (validUntil > consts_1.U32_MAX) {
                        validUntil = consts_1.U32_MAX;
                    }
                    gasLimit = encodedGasLimit.mul(consts_1.GAS_LIMIT_CHUNK).toBigInt();
                    storageLimit = ethers_1.BigNumber.from(2)
                        .pow(encodedStorageLimit.gt(consts_1.MAX_GAS_LIMIT_CC) ? consts_1.MAX_GAS_LIMIT_CC : encodedStorageLimit)
                        .toBigInt();
                }
            }
            else if (ethTx.type === 1 || ethTx.type === 2) {
                return utils_2.logger.throwError(`unsupported transaction type: ${ethTx.type}, please use legacy or EIP-712 instead.`, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: '_getSubstrateGasParams',
                    transactionType: ethTx.type,
                });
            }
            return {
                gasLimit,
                storageLimit,
                validUntil,
                tip,
                accessList: ethTx.accessList ?? [],
                v2,
            };
        };
        this.prepareTransaction = async (rawTx) => {
            const signatureType = (0, eth_transactions_1.checkSignatureType)(rawTx);
            const ethTx = (0, eth_transactions_1.parseTransaction)(rawTx);
            if (!ethTx.from) {
                return utils_2.logger.throwError('missing from address', logger_1.Logger.errors.INVALID_ARGUMENT, ethTx);
            }
            const { storageLimit, gasLimit, tip, accessList, validUntil, v2 } = this._getSubstrateGasParams(ethTx);
            // check excuted error
            const callRequest = {
                from: ethTx.from,
                to: ethTx.to,
                gasLimit: gasLimit,
                storageLimit: storageLimit,
                value: ethTx.value.toString(),
                data: ethTx.data,
                accessList: ethTx.accessList,
            };
            await this._ethCall(callRequest);
            const extrinsic = v2
                ? this.api.tx.evm.ethCallV2(ethTx.to ? { Call: ethTx.to } : { Create: null }, ethTx.data, ethTx.value.toString(), ethTx.gasPrice?.toBigInt(), ethTx.gasLimit.toBigInt(), accessList)
                : this.api.tx.evm.ethCall(ethTx.to ? { Call: ethTx.to } : { Create: null }, ethTx.data, ethTx.value.toString(), gasLimit, storageLimit, accessList, validUntil);
            const subAddr = await this.getSubstrateAddress(ethTx.from);
            const sig = (0, bytes_1.joinSignature)({ r: ethTx.r, s: ethTx.s, v: ethTx.v });
            extrinsic.addSignature(subAddr, { [signatureType]: sig }, {
                blockHash: '0x',
                era: '0x00',
                genesisHash: '0x',
                method: 'Bytes',
                specVersion: 0,
                transactionVersion: 0,
                nonce: ethTx.nonce,
                tip,
            });
            return {
                extrinsic,
                transaction: ethTx,
            };
        };
        this.sendRawTransaction = async (rawTx) => {
            const { extrinsic } = await this.prepareTransaction(rawTx);
            await extrinsic.send();
            return extrinsic.hash.toHex();
        };
        this.sendTransaction = async (signedTransaction) => {
            const hexTx = await Promise.resolve(signedTransaction).then((t) => (0, bytes_1.hexlify)(t));
            const tx = (0, eth_transactions_1.parseTransaction)(await signedTransaction);
            if (tx.confirmations === null || tx.confirmations === undefined) {
                tx.confirmations = 0;
            }
            try {
                const { extrinsic, transaction } = await this.prepareTransaction(hexTx);
                //@TODO
                // wait for tx in block
                const result = await (0, utils_2.sendTx)(this.api, extrinsic);
                const blockHash = result.status.isInBlock ? result.status.asInBlock : result.status.asFinalized;
                const header = await this._getBlockHeader(blockHash.toHex());
                const blockNumber = header.number.toNumber();
                const hash = extrinsic.hash.toHex();
                return this._wrapTransaction(transaction, hash, blockNumber, blockHash.toHex());
            }
            catch (err) {
                const error = err;
                for (const pattern of consts_1.ERROR_PATTERN) {
                    const match = (error.toString?.() || '').match(pattern);
                    if (match) {
                        const errDetails = this.api.registry.findMetaError(new Uint8Array([parseInt(match[1]), parseInt(match[2])]));
                        // error.message is readonly, so construct a new error object
                        throw new Error(JSON.stringify({
                            message: `${errDetails.section}.${errDetails.name}: ${errDetails.docs}`,
                            transaction: tx,
                            transactionHash: tx.hash,
                        }));
                    }
                }
                error.transaction = tx;
                error.transactionHash = tx.hash;
                throw error;
            }
        };
        this._wrapTransaction = async (tx, hash, startBlock, startBlockHash) => {
            if (hash !== null && hash !== undefined && (0, bytes_1.hexDataLength)(hash) !== 32) {
                throw new Error('invalid hash - sendTransaction');
            }
            // Check the hash we expect is the same as the hash the server reported
            // @TODO expectedHash
            // if (hash != null && tx.hash !== hash) {
            //   logger.throwError('Transaction hash mismatch from Provider.sendTransaction.', Logger.errors.UNKNOWN_ERROR, {
            //     expectedHash: tx.hash,
            //     returnedHash: hash
            //   });
            // }
            const result = tx;
            // fix tx hash
            result.hash = hash;
            result.blockNumber = startBlock;
            result.blockHash = startBlockHash;
            result.timestamp = Math.floor((await this.queryStorage('timestamp.now', [], result.blockHash)).toNumber() / 1000);
            result.wait = async (confirms, timeoutMs) => {
                if (confirms === null || confirms === undefined) {
                    confirms = 1;
                }
                else if (confirms < 0) {
                    throw new Error('invalid confirms value');
                }
                if (timeoutMs === null || timeoutMs === undefined) {
                    timeoutMs = 0;
                }
                else if (timeoutMs < 0) {
                    throw new Error('invalid timeout value');
                }
                let wait$ = timeoutMs ? this.head$.pipe((0, operators_1.timeout)({
                    first: timeoutMs,
                    with: () => (0, rxjs_1.throwError)(() => utils_2.logger.makeError('timeout exceeded', logger_1.Logger.errors.TIMEOUT, { timeout: timeoutMs })),
                })) : this.head$;
                wait$ = wait$.pipe((0, operators_1.first)((head) => head.number.toNumber() - startBlock + 1 >= confirms));
                await (0, rxjs_1.firstValueFrom)(wait$);
                const receipt = await this.getReceiptAtBlockFromChain(hash, startBlockHash);
                // tx was just mined so won't be null
                return receipt;
            };
            return result;
        };
        this._getBlockNumber = async (blockTag) => {
            switch (blockTag) {
                case 'pending': {
                    return utils_2.logger.throwError('pending tag not implemented', logger_1.Logger.errors.UNSUPPORTED_OPERATION);
                }
                case 'latest': {
                    return this.getBlockNumber();
                }
                case 'earliest': {
                    return 0;
                }
                case 'finalized':
                case 'safe': {
                    return this.finalizedBlockNumber;
                }
                default: {
                    if ((0, bytes_1.isHexString)(blockTag, 32)) {
                        return (await this._getBlockHeader(blockTag)).number.toNumber();
                    }
                    else if ((0, bytes_1.isHexString)(blockTag) || typeof blockTag === 'number') {
                        return ethers_1.BigNumber.from(blockTag).toNumber();
                    }
                    return utils_2.logger.throwArgumentError('blocktag should be number | hex string | \'latest\' | \'earliest\' | \'finalized\' | \'safe\'', 'blockTag', blockTag);
                }
            }
        };
        this._getBlockHash = async (_blockTag) => {
            const blockTag = (await _blockTag) || 'latest';
            switch (blockTag) {
                case 'pending': {
                    return utils_2.logger.throwError('pending tag not implemented', logger_1.Logger.errors.UNSUPPORTED_OPERATION);
                }
                case 'latest': {
                    return this.safeMode ? this.finalizedBlockHash : this.bestBlockHash;
                }
                case 'earliest': {
                    const hash = this.api.genesisHash;
                    return hash.toHex();
                }
                case 'finalized':
                case 'safe': {
                    return this.finalizedBlockHash;
                }
                default: {
                    if ((0, bytes_1.isHexString)(blockTag, 32)) {
                        return blockTag;
                    }
                    else if ((0, bytes_1.isHexString)(blockTag) || typeof blockTag === 'number') {
                        const blockNumber = ethers_1.BigNumber.from(blockTag);
                        // max blockNumber is u32
                        if (blockNumber.gt(0xffffffff)) {
                            return utils_2.logger.throwArgumentError('block number should be less than u32', 'blockNumber', blockNumber);
                        }
                        const isFinalized = blockNumber.lte(await this.finalizedBlockNumber);
                        const cacheKey = `blockHash-${blockNumber.toString()}`;
                        if (isFinalized) {
                            const cached = this.storageCache.get(cacheKey);
                            if (cached) {
                                return (0, util_1.u8aToHex)(cached);
                            }
                        }
                        const _blockHash = await this.api.rpc.chain.getBlockHash(blockNumber.toBigInt());
                        if (_blockHash.isEmpty) {
                            //@ts-ignore
                            return utils_2.logger.throwError('header not found', utils_2.PROVIDER_ERRORS.HEADER_NOT_FOUND, { blockNumber });
                        }
                        const blockHash = _blockHash.toHex();
                        if (isFinalized) {
                            this.storageCache.set(cacheKey, _blockHash.toU8a());
                        }
                        return blockHash;
                    }
                    return utils_2.logger.throwArgumentError('blocktag should be number | hex string | \'latest\' | \'earliest\' | \'finalized\' | \'safe\'', 'blockTag', blockTag);
                }
            }
        };
        this._isBlockCanonical = async (blockHash, _blockNumber) => {
            if (this.finalizedBlockHashes.has(blockHash))
                return true;
            const blockNumber = _blockNumber ?? (await this._getBlockNumber(blockHash));
            const canonicalHash = await this.api.rpc.chain.getBlockHash(blockNumber);
            return canonicalHash.toString() === blockHash;
        };
        this._isBlockFinalized = async (blockTag) => {
            const [blockHash, blockNumber] = await Promise.all([
                this._getBlockHash(blockTag),
                this._getBlockNumber(blockTag),
            ]);
            return (await this.finalizedBlockNumber >= blockNumber &&
                await this._isBlockCanonical(blockHash, blockNumber));
        };
        this._isTransactionFinalized = async (txHash) => {
            const tx = await this.getReceipt(txHash);
            if (!tx)
                return false;
            return this._isBlockFinalized(tx.blockHash);
        };
        this._ensureSafeModeBlockTagFinalization = async (_blockTag) => {
            if (!this.safeMode || !_blockTag)
                return _blockTag;
            const blockTag = await _blockTag;
            if (blockTag === 'latest')
                return this.finalizedBlockHash;
            const isBlockFinalized = await this._isBlockFinalized(blockTag);
            return isBlockFinalized
                ? blockTag
                : // We can also throw header not found error here, which is more consistent with actual block not found error. However, This error is more informative.
                    utils_2.logger.throwError('SAFE MODE ERROR: target block is not finalized', logger_1.Logger.errors.UNKNOWN_ERROR, { blockTag });
        };
        this._getBlockHeader = async (blockTag) => {
            const blockHash = await this._getBlockHash(blockTag);
            try {
                const header = await this.api.rpc.chain.getHeader(blockHash);
                return header;
            }
            catch (error) {
                if (typeof error === 'object' &&
                    typeof error.message === 'string' &&
                    error.message.match(/Unable to retrieve header and parent from supplied hash/gi)) {
                    //@ts-ignore
                    return utils_2.logger.throwError('header not found', utils_2.PROVIDER_ERRORS.HEADER_NOT_FOUND, { blockHash });
                }
                throw error;
            }
        };
        this._getAddress = async (addressOrName) => {
            addressOrName = await addressOrName;
            return addressOrName;
        };
        // from chain only
        this.getReceiptAtBlockFromChain = async (txHash, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(await (0, utils_2.parseBlockTag)(_blockTag));
            const blockHash = await this._getBlockHash(blockTag);
            const receipt = (await (0, utils_2.getAllReceiptsAtBlock)(this.api, blockHash, await txHash))[0];
            return receipt ?? null;
        };
        // from cache or subql
        this.getReceiptAtBlock = async (hashOrNumber, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(await (0, utils_2.parseBlockTag)(_blockTag));
            hashOrNumber = await hashOrNumber;
            const blockHash = await this._getBlockHash(blockTag);
            return (0, bytes_1.isHexString)(hashOrNumber, 32)
                ? this._getReceiptAtBlockByHash(hashOrNumber, blockHash)
                : this._getReceiptAtBlockByIndex(hashOrNumber, blockHash);
        };
        this._getReceiptAtBlockByHash = async (txHash, blockHash) => {
            const receipt = await this.getReceipt(txHash);
            return receipt?.blockHash === blockHash ? receipt : null;
        };
        this._getReceiptAtBlockByIndex = async (txIdx, blockHash) => {
            // TODO: remove me after new subql re-indexing, it should be sorted automatically
            const sortByTxIdx = (0, utils_2.sortObjByKey)('transactionIndex');
            const receiptIdx = ethers_1.BigNumber.from(txIdx).toNumber();
            const receiptFromCache = this.blockCache.getAllReceiptsAtBlock(blockHash).sort(sortByTxIdx)[receiptIdx];
            if (receiptFromCache && (await this._isBlockCanonical(receiptFromCache.blockHash, receiptFromCache.blockNumber)))
                return receiptFromCache;
            const receiptsAtBlock = await this.subql?.getAllReceiptsAtBlock(blockHash);
            const sortedReceipts = receiptsAtBlock?.sort(sortByTxIdx);
            return sortedReceipts?.[receiptIdx] ? (0, utils_2.subqlReceiptAdapter)(sortedReceipts[receiptIdx]) : null;
        };
        // TODO: test pending
        this._getPendingTX = async (txHash) => {
            const pendingExtrinsics = await this.api.rpc.author.pendingExtrinsics();
            const targetExtrinsic = pendingExtrinsics.find((ex) => ex.hash.toHex() === txHash);
            if (!(targetExtrinsic && (0, utils_2.isEvmExtrinsic)(targetExtrinsic)))
                return null;
            return {
                from: await this.getEvmAddress(targetExtrinsic.signer.toString()),
                blockHash: null,
                blockNumber: null,
                transactionIndex: null,
                hash: txHash,
                gasPrice: 0,
                ...(0, utils_2.parseExtrinsic)(targetExtrinsic),
            };
        };
        // Queries
        this.getTransaction = (_txHash) => (0, utils_2.throwNotImplemented)('getTransaction (deprecated: please use getTransactionByHash)');
        this.getTransactionByHash = async (txHash) => {
            if (!this.localMode) {
                // local mode is for local instant-sealing node
                // so ignore pending tx to avoid some timing issue
                const pendingTX = await this._getPendingTX(txHash);
                if (pendingTX)
                    return pendingTX;
            }
            const receipt = await this.getReceipt(txHash);
            if (!receipt)
                return null;
            // TODO: in the future can save parsed extraData in FullReceipt for ultimate performance
            // it's free info from getAllReceiptsAtBlock but requires 1 extra async call here
            const block = await this.api.rpc.chain.getBlock(receipt.blockHash);
            return (0, utils_2.receiptToTransaction)(receipt, block);
        };
        this.getTransactionReceipt = async (_txHash) => (0, utils_2.throwNotImplemented)('getTransactionReceipt (please use `getReceipt` instead)');
        this.getReceipt = async (txHash) => this.localMode
            ? await (0, utils_2.runWithRetries)(this._getReceipt.bind(this), [txHash])
            : await this._getReceipt(txHash);
        this._getReceipt = async (txHash) => {
            const txFromCache = this.blockCache.getReceiptByHash(txHash);
            if (txFromCache &&
                await this._isBlockCanonical(txFromCache.blockHash, txFromCache.blockNumber))
                return txFromCache;
            // smallest block number to make sure there is no gap between subql and block cache
            const subqlTargetBlock = await this.bestBlockNumber - this.blockCache.cachedBlockHashes.length + 1;
            await this._waitForSubql(subqlTargetBlock);
            const txFromSubql = await this.subql?.getTxReceiptByHash(txHash);
            return txFromSubql
                ? (0, utils_2.subqlReceiptAdapter)(txFromSubql)
                : null;
        };
        this._sanitizeRawFilter = async (rawFilter) => {
            const { fromBlock, toBlock, blockHash, address, topics } = rawFilter;
            const filter = {
                address,
                topics,
            };
            if (blockHash && (fromBlock || toBlock)) {
                return utils_2.logger.throwError('`fromBlock` and `toBlock` is not allowed in params when `blockHash` is present', logger_1.Logger.errors.INVALID_ARGUMENT, {
                    blockHash,
                    fromBlock,
                    toBlock,
                });
            }
            if (blockHash) {
                // eip-1898
                const blockNumber = (await this._getBlockHeader(blockHash)).number.toNumber();
                filter.fromBlock = blockNumber;
                filter.toBlock = blockNumber;
            }
            else {
                const fromBlockNumber = await this._getBlockNumber(fromBlock ?? 'latest');
                const toBlockNumber = await this._getBlockNumber(toBlock ?? 'latest');
                filter.fromBlock = fromBlockNumber;
                filter.toBlock = toBlockNumber;
            }
            return filter;
        };
        // Bloom-filter Queries
        this.getLogs = async (rawFilter) => {
            if (!this.subql) {
                return utils_2.logger.throwError('missing subql url to fetch logs, to initialize base provider with subql, please provide a subqlUrl param.');
            }
            const filter = await this._sanitizeRawFilter(rawFilter);
            await this._waitForSubql(filter.toBlock);
            const subqlLogs = await this.subql.getFilteredLogs(filter); // only filtered by blockNumber and address
            return subqlLogs
                .filter(log => (0, utils_2.filterLogByTopics)(log, filter.topics))
                .map(log => this.formatter.filterLog(log));
        };
        /* ----------
           make sure subql already indexed to target block number
           currently unfinalized blocks indexing is NOT enabled
           so upper bound would be finalized block number
                                                       ---------- */
        this._waitForSubql = async (_targetBlock) => {
            if (!this.subql)
                return;
            const SUBQL_MAX_WAIT_BLOCKS = 3;
            const upperBound = await this.finalizedBlockNumber;
            const targetBlock = Math.min(_targetBlock, upperBound);
            let lastProcessedHeight = await this.subql.getLastProcessedHeight();
            if (targetBlock - lastProcessedHeight > SUBQL_MAX_WAIT_BLOCKS) {
                return utils_2.logger.throwError(`subql indexer is not synced to target block, please wait for it to catch up. Estimated ${(targetBlock - lastProcessedHeight) * 12}s remaining ...`, logger_1.Logger.errors.SERVER_ERROR, { targetBlock, lastProcessedHeight });
            }
            // wait at most 3 * 12 = 36s
            while (lastProcessedHeight < targetBlock) {
                await (0, utils_2.sleep)(1000);
                lastProcessedHeight = await this.subql.getLastProcessedHeight();
            }
        };
        this.getIndexerMetadata = async () => {
            return this.subql?.getIndexerMetadata();
        };
        this.getCachInfo = () => this.blockCache.inspect();
        this._timeEthCalls = async () => {
            const HEALTH_CHECK_BLOCK_DISTANCE = 100;
            const gasPricePromise = (0, utils_2.runWithTiming)(async () => this.getGasPrice());
            const estimateGasPromise = (0, utils_2.runWithTiming)(async () => this.estimateGas({
                from: '0xe3234f433914d4cfcf846491ec5a7831ab9f0bb3',
                value: '0x0',
                gasPrice: '0x2f0276000a',
                data: '0x',
                to: '0x22293227a254a481883ca5e823023633308cb9ca',
            }));
            // ideally pastNblock should have EVM TX
            const finalizedBlockNumber = await this.finalizedBlockNumber;
            const pastNblock = finalizedBlockNumber > HEALTH_CHECK_BLOCK_DISTANCE
                ? finalizedBlockNumber - HEALTH_CHECK_BLOCK_DISTANCE
                : finalizedBlockNumber;
            const getBlockPromise = (0, utils_2.runWithTiming)(async () => this.getBlockData(pastNblock, false));
            const getFullBlockPromise = (0, utils_2.runWithTiming)(async () => this.getBlockData(pastNblock, true));
            const [gasPriceTime, estimateGasTime, getBlockTime, getFullBlockTime] = (await Promise.all([gasPricePromise, estimateGasPromise, getBlockPromise, getFullBlockPromise])).map((res) => Math.floor(res.time));
            return {
                gasPriceTime,
                estimateGasTime,
                getBlockTime,
                getFullBlockTime,
            };
        };
        this.healthCheck = async () => {
            const [indexerMeta, ethCallTiming] = await Promise.all([
                this.getIndexerMetadata(),
                this._timeEthCalls(),
            ]);
            const cacheInfo = this.getCachInfo();
            const curFinalizedHeight = await this.finalizedBlockNumber;
            const listenersCount = {
                newHead: this.eventListeners[SubscriptionType.NewHeads]?.length || 0,
                newFinalizedHead: this.eventListeners[SubscriptionType.NewFinalizedHeads]?.length || 0,
                logs: this.eventListeners[SubscriptionType.Logs]?.length || 0,
            };
            return (0, utils_2.getHealthResult)({
                indexerMeta,
                cacheInfo,
                curFinalizedHeight,
                ethCallTiming,
                listenersCount,
            });
        };
        // ENS
        this.lookupAddress = (_address) => (0, utils_2.throwNotImplemented)('lookupAddress');
        this.waitForTransaction = (_transactionHash, _confirmations, _timeout) => (0, utils_2.throwNotImplemented)('waitForTransaction');
        // Event Emitter (ish)
        this.addEventListener = (eventName, listener, filter = {}) => {
            const id = ethers_1.Wallet.createRandom().address;
            const eventCallBack = (data) => listener({
                subscription: id,
                result: data,
            });
            if (eventName === SubscriptionType.NewHeads) {
                this.eventListeners[eventName].push({ cb: eventCallBack, id });
            }
            else if (eventName === SubscriptionType.NewFinalizedHeads) {
                this.eventListeners[eventName].push({ cb: eventCallBack, id });
            }
            else if (eventName === SubscriptionType.Logs) {
                this.eventListeners[eventName].push({ cb: eventCallBack, filter, id });
            }
            else {
                return utils_2.logger.throwError(`subscription type [${eventName}] is not supported, expect ${Object.values(SubscriptionType)}`, logger_1.Logger.errors.INVALID_ARGUMENT);
            }
            return id;
        };
        this.removeEventListener = (id) => {
            let found = false;
            Object.values(SubscriptionType).forEach((e) => {
                const targetIdx = this.eventListeners[e].findIndex((l) => l.id === id);
                if (targetIdx !== undefined && targetIdx !== -1) {
                    this.eventListeners[e].splice(targetIdx, 1);
                    found = true;
                }
            });
            return found;
        };
        this.addPollFilter = async (filterType, logFilter = {}) => {
            const id = ethers_1.Wallet.createRandom().address;
            const baseFilter = {
                id,
                lastPollBlockNumber: await this.getBlockNumber(),
                lastPollTimestamp: Date.now(), // TODO: add expire
            };
            if (filterType === PollFilterType.NewBlocks) {
                this.pollFilters[filterType].push(baseFilter);
            }
            else if (filterType === PollFilterType.Logs) {
                this.pollFilters[filterType].push({
                    ...baseFilter,
                    logFilter,
                });
            }
            else {
                return utils_2.logger.throwError(`filter type [${filterType}] is not supported, expect ${Object.values(PollFilterType)}`, logger_1.Logger.errors.INVALID_ARGUMENT);
            }
            return id;
        };
        this._pollLogs = async (filterInfo) => {
            const curBlockNumber = await this.getBlockNumber();
            const { fromBlock = 'latest', toBlock = 'latest' } = filterInfo.logFilter;
            const UNSUPPORTED_TAGS = ['pending', 'finalized', 'safe'];
            if (UNSUPPORTED_TAGS.includes(fromBlock) || UNSUPPORTED_TAGS.includes(toBlock)) {
                return utils_2.logger.throwArgumentError('pending/finalized/safe logs not supported', 'fromBlock / toBlock', {
                    fromBlock,
                    toBlock,
                });
            }
            const sanitizedFilter = await this._sanitizeRawFilter(filterInfo.logFilter);
            /* ---------------
               compute the configuration filter range
               in this context we treat 'latest' blocktag in *rawFilter* as trivial filter
               i.e. default fromBlock and toBlock are both 'latest', which filters nothing
                                                                           --------------- */
            const from = fromBlock === 'latest' ? 0 : sanitizedFilter.fromBlock ?? 0;
            const to = toBlock === 'latest' ? 999999999 : sanitizedFilter.toBlock ?? 999999999;
            /* ---------------
               combine configuration filter range [from, to] and
               dynamic data range [lastPollBlockNumber + 1, curBlockNumber]
               as the final effective range to query
                                                            --------------- */
            const effectiveFrom = Math.max(from, filterInfo.lastPollBlockNumber + 1);
            const effectiveTo = Math.min(to, curBlockNumber);
            if (effectiveFrom > effectiveTo) {
                return [];
            }
            const effectiveFilter = {
                ...sanitizedFilter,
                fromBlock: effectiveFrom,
                toBlock: effectiveTo,
            };
            if (!this.subql) {
                return utils_2.logger.throwError('missing subql url to fetch logs, to initialize base provider with subql, please provide a subqlUrl param.');
            }
            filterInfo.lastPollBlockNumber = curBlockNumber;
            filterInfo.lastPollTimestamp = Date.now();
            const subqlLogs = await this.subql.getFilteredLogs(effectiveFilter); // FIXME: this misses unfinalized logs
            const filteredLogs = subqlLogs.filter((log) => (0, utils_2.filterLogByTopics)(log, sanitizedFilter.topics));
            return (0, utils_2.hexlifyRpcResult)(filteredLogs.map((log) => this.formatter.filterLog(log)));
        };
        this._pollBlocks = async (filterInfo) => {
            const curBlockNumber = await this.getBlockNumber();
            const newBlockHashesPending = [];
            for (let blockNum = filterInfo.lastPollBlockNumber + 1; blockNum <= curBlockNumber; blockNum++) {
                newBlockHashesPending.push(this._getBlockHash(blockNum));
            }
            filterInfo.lastPollBlockNumber = curBlockNumber;
            filterInfo.lastPollTimestamp = Date.now();
            return Promise.all(newBlockHashesPending);
        };
        this.poll = async (id, logsOnly = false) => {
            const logFilterInfo = this.pollFilters[PollFilterType.Logs].find((f) => f.id === id);
            const blockFilterInfo = !logsOnly && this.pollFilters[PollFilterType.NewBlocks].find((f) => f.id === id);
            const filterInfo = logFilterInfo ?? blockFilterInfo;
            if (!filterInfo) {
                return utils_2.logger.throwError('filter not found', logger_1.Logger.errors.UNKNOWN_ERROR, { filterId: id });
            }
            // TODO: TS bug?? why filterInfo type is not BlockPollFilter | LogPollFilter
            return filterInfo['logFilter'] ? this._pollLogs(filterInfo) : this._pollBlocks(filterInfo);
        };
        this.removePollFilter = (id) => {
            let found = false;
            Object.values(PollFilterType).forEach((f) => {
                const targetIdx = this.pollFilters[f].findIndex((f) => f.id === id);
                if (targetIdx !== undefined && targetIdx !== -1) {
                    this.pollFilters[f].splice(targetIdx, 1);
                    found = true;
                }
            });
            return found;
        };
        this.on = (_eventName, _listener) => (0, utils_2.throwNotImplemented)('on');
        this.once = (_eventName, _listener) => (0, utils_2.throwNotImplemented)('once');
        this.emit = (_eventName, ..._args) => (0, utils_2.throwNotImplemented)('emit');
        this.listenerCount = (_eventName) => (0, utils_2.throwNotImplemented)('listenerCount');
        this.listeners = (_eventName) => (0, utils_2.throwNotImplemented)('listeners');
        this.off = (_eventName, _listener) => (0, utils_2.throwNotImplemented)('off');
        this.removeAllListeners = (_eventName) => (0, utils_2.throwNotImplemented)('removeAllListeners');
        this.formatter = new providers_1.Formatter();
        this.eventListeners = {
            [SubscriptionType.NewHeads]: [],
            [SubscriptionType.NewFinalizedHeads]: [],
            [SubscriptionType.Logs]: [],
        };
        this.pollFilters = { [PollFilterType.NewBlocks]: [], [PollFilterType.Logs]: [] };
        this.safeMode = safeMode;
        this.localMode = localMode;
        this.verbose = verbose;
        this.maxBlockCacheSize = maxBlockCacheSize;
        this.storageCache = new lru_cache_1.default({ max: storageCacheSize });
        this.blockCache = new BlockCache_1.BlockCache(this.maxBlockCacheSize);
        this.finalizedBlockHashes = new MaxSizeSet_1.MaxSizeSet(this.maxBlockCacheSize);
        this.subql = subqlUrl ? new subqlProvider_1.SubqlProvider(subqlUrl) : undefined;
        /* ---------- messages ---------- */
        safeMode && utils_2.logger.warn(consts_1.SAFE_MODE_WARNING_MSG);
        this.verbose && utils_2.logger.warn(localMode ? consts_1.LOCAL_MODE_MSG : consts_1.PROD_MODE_MSG);
        if (this.maxBlockCacheSize < 0) {
            return utils_2.logger.throwError(`expect maxBlockCacheSize >= 0, but got ${this.maxBlockCacheSize}`, logger_1.Logger.errors.INVALID_ARGUMENT);
        }
        else {
            this.maxBlockCacheSize > 9999 && utils_2.logger.warn(consts_1.CACHE_SIZE_WARNING);
        }
    }
    get bestBlockHash() {
        return (0, rxjs_1.firstValueFrom)(this.best$).then(({ hash }) => hash);
    }
    get bestBlockNumber() {
        return (0, rxjs_1.firstValueFrom)(this.best$).then(({ number }) => number);
    }
    get finalizedBlockHash() {
        return (0, rxjs_1.firstValueFrom)(this.finalized$).then(({ hash }) => hash);
    }
    get finalizedBlockNumber() {
        return (0, rxjs_1.firstValueFrom)(this.finalized$).then(({ number }) => number);
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
    get api() {
        return this._api ?? utils_2.logger.throwError('the api needs to be set', logger_1.Logger.errors.UNKNOWN_ERROR);
    }
    get genesisHash() {
        return this.api.genesisHash.toHex();
    }
    get isConnected() {
        return this.api.isConnected;
    }
    get chainDecimal() {
        return this.api.registry.chainDecimals[0] || 10;
    }
    get isSafeMode() {
        return this.safeMode;
    }
}
exports.BaseProvider = BaseProvider;
_BaseProvider_subscription = new WeakMap(), _BaseProvider_async = new WeakMap(), _BaseProvider_headTasks = new WeakMap(), _BaseProvider_finalizedHeadTasks = new WeakMap();
