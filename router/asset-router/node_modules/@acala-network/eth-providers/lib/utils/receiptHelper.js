"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.receiptToTransaction = exports.subqlReceiptAdapter = exports.getOrphanTxReceiptsFromEvents = exports.fullReceiptFormatter = exports.formatter = exports.parseExtrinsic = exports.findEvmEvent = exports.getPartialTransactionReceipt = exports.getPartialLogs = exports.getPartialLog = void 0;
const consts_1 = require("../consts");
const bignumber_1 = require("@ethersproject/bignumber");
const providers_1 = require("@ethersproject/providers");
const util_1 = require("@polkadot/util");
const bytes_1 = require("@ethersproject/bytes");
const utils_1 = require("./utils");
const keccak256_1 = require("@ethersproject/keccak256");
const logger_1 = require("./logger");
const getPartialLog = (evmLog, logIndex) => {
    return {
        removed: false,
        address: evmLog.address.toString().toLowerCase(),
        data: evmLog.data.toString().toLowerCase(),
        topics: evmLog.topics.toJSON(),
        logIndex: logIndex,
    };
};
exports.getPartialLog = getPartialLog;
const getPartialLogs = (evmLogs) => {
    return evmLogs.map((log, index) => (0, exports.getPartialLog)(log, index));
};
exports.getPartialLogs = getPartialLogs;
const DUMMY_LOGS_BLOOM = '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
const getPartialTransactionReceipt = (event) => {
    const defaultValue = {
        logsBloom: DUMMY_LOGS_BLOOM,
        type: 0,
        cumulativeGasUsed: consts_1.BIGNUMBER_ZERO,
    };
    switch (event.event.method) {
        case 'Created': {
            const [source, evmAddress, logs, usedGas] = event.event.data;
            return {
                to: undefined,
                from: source.toHex(),
                contractAddress: evmAddress.toString(),
                gasUsed: bignumber_1.BigNumber.from(usedGas?.toString() || 0),
                status: 1,
                logs: (0, exports.getPartialLogs)(logs),
                ...defaultValue,
            };
        }
        case 'Executed': {
            const [source, evmAddress, logs, usedGas] = event.event.data;
            return {
                to: evmAddress.toString(),
                from: source.toHex(),
                contractAddress: undefined,
                gasUsed: bignumber_1.BigNumber.from(usedGas?.toString() || 0),
                logs: (0, exports.getPartialLogs)(logs),
                status: 1,
                ...defaultValue,
            };
        }
        case 'CreatedFailed': {
            const [source, evmAddress, _exitReason, logs, usedGas] = event.event.data;
            return {
                to: undefined,
                from: source.toHex(),
                contractAddress: evmAddress.toString(),
                gasUsed: bignumber_1.BigNumber.from(usedGas?.toString() || 0),
                logs: (0, exports.getPartialLogs)(logs),
                status: 0,
                exitReason: _exitReason.toString(),
                ...defaultValue,
            };
        }
        case 'ExecutedFailed': {
            const [source, evmAddress, _exitReason, , logs, usedGas] = event.event.data;
            return {
                to: evmAddress.toString(),
                from: source.toHex(),
                contractAddress: undefined,
                gasUsed: bignumber_1.BigNumber.from(usedGas?.toString() || 0),
                status: 0,
                exitReason: _exitReason.toString(),
                logs: (0, exports.getPartialLogs)(logs),
                ...defaultValue,
            };
        }
    }
    return logger_1.logger.throwError(`unsupported event: ${event.event.method}`);
};
exports.getPartialTransactionReceipt = getPartialTransactionReceipt;
const findEvmEvent = (events) => {
    return events
        .filter((event) => event.event.section.toUpperCase() === 'EVM' &&
        ['Created', 'CreatedFailed', 'Executed', 'ExecutedFailed'].includes(event.event.method))
        .reduce((r, event) => {
        // For the moment the case of multiple evm events in one transaction only support Executed
        if (r.event.method === 'Executed' && r.event.method === event.event.method) {
            const logs = event.event.data[2];
            const newLogs = r.event.data[2].concat(logs);
            r.event.data[2] = newLogs;
        }
        return r;
    });
};
exports.findEvmEvent = findEvmEvent;
// parse info that can be extracted from extrinsic alone
// only works for EVM extrinsics
const parseExtrinsic = (extrinsic) => {
    const nonce = extrinsic.nonce.toNumber();
    const NONE_EVM_TX_DEFAULT_DATA = {
        value: '0x0',
        gas: 2100000,
        input: '0x',
        to: null,
        nonce,
        ...consts_1.DUMMY_V_R_S, // TODO: get correct VRS
    };
    if (extrinsic.method.section.toUpperCase() !== 'EVM') {
        return NONE_EVM_TX_DEFAULT_DATA;
    }
    const args = extrinsic.method.toJSON().args;
    return {
        value: (0, bytes_1.hexValue)(args.value || 0),
        gas: args.gas_limit || 0,
        input: args.input || args.init || '0x',
        to: args.action?.call || args.target || null,
        nonce,
        ...consts_1.DUMMY_V_R_S,
    };
};
exports.parseExtrinsic = parseExtrinsic;
// a simulation of nToU8a from @polkadot/api@8
const nToU8aLegacy = (...params) => {
    return params[0] === 0 ? new Uint8Array() : (0, util_1.nToU8a)(...params);
};
exports.formatter = new providers_1.Formatter();
exports.fullReceiptFormatter = {
    ...exports.formatter.formats.receipt,
    exitReason: (x) => x,
};
const getOrphanTxReceiptsFromEvents = (events, blockHash, blockNumber, indexOffset) => {
    const receipts = events
        .filter(utils_1.isOrphanEvmEvent)
        .map(exports.getPartialTransactionReceipt)
        .map((partialReceipt, i) => {
        const transactionHash = (0, keccak256_1.keccak256)([...(0, util_1.hexToU8a)(blockHash), ...nToU8aLegacy(i)]);
        const txInfo = {
            transactionIndex: indexOffset + i,
            transactionHash,
            blockHash,
            blockNumber,
        };
        const logs = partialReceipt.logs.map((log) => ({
            ...log,
            ...txInfo,
        }));
        return {
            effectiveGasPrice: consts_1.BIGNUMBER_ZERO,
            ...partialReceipt,
            ...txInfo,
            logs,
        };
    });
    return receipts.map((receipt) => providers_1.Formatter.check(exports.fullReceiptFormatter, receipt));
};
exports.getOrphanTxReceiptsFromEvents = getOrphanTxReceiptsFromEvents;
const subqlReceiptAdapter = (receipt) => receipt
    ? providers_1.Formatter.check(exports.fullReceiptFormatter, {
        ...receipt,
        logs: receipt.logs.nodes,
    })
    : null;
exports.subqlReceiptAdapter = subqlReceiptAdapter;
const receiptToTransaction = (tx, block) => {
    const extrinsic = block.block.extrinsics.find((ex) => ex.hash.toHex() === tx.transactionHash);
    const extraData = extrinsic ? (0, exports.parseExtrinsic)(extrinsic) : consts_1.ORPHAN_TX_DEFAULT_INFO;
    return {
        blockHash: tx.blockHash,
        blockNumber: tx.blockNumber,
        transactionIndex: tx.transactionIndex,
        hash: tx.transactionHash,
        from: tx.from,
        gasPrice: tx.effectiveGasPrice,
        ...extraData,
        // overrides `to` in parseExtrinsic, in case of non-evm extrinsic, such as dex.xxx
        to: tx.to || null,
    };
};
exports.receiptToTransaction = receiptToTransaction;
