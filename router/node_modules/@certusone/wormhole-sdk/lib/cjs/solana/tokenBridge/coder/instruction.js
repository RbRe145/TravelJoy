"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBridgeInstruction = exports.TokenBridgeInstructionCoder = void 0;
var web3_js_1 = require("@solana/web3.js");
var TokenBridgeInstructionCoder = /** @class */ (function () {
    function TokenBridgeInstructionCoder(_) {
    }
    TokenBridgeInstructionCoder.prototype.encode = function (ixName, ix) {
        switch (ixName) {
            case "initialize": {
                return encodeInitialize(ix);
            }
            case "attestToken": {
                return encodeAttestToken(ix);
            }
            case "completeNative": {
                return encodeCompleteNative(ix);
            }
            case "completeWrapped": {
                return encodeCompleteWrapped(ix);
            }
            case "transferWrapped": {
                return encodeTransferWrapped(ix);
            }
            case "transferNative": {
                return encodeTransferNative(ix);
            }
            case "registerChain": {
                return encodeRegisterChain(ix);
            }
            case "createWrapped": {
                return encodeCreateWrapped(ix);
            }
            case "upgradeContract": {
                return encodeUpgradeContract(ix);
            }
            case "transferWrappedWithPayload": {
                return encodeTransferWrappedWithPayload(ix);
            }
            case "transferNativeWithPayload": {
                return encodeTransferNativeWithPayload(ix);
            }
            default: {
                throw new Error("Invalid instruction: " + ixName);
            }
        }
    };
    TokenBridgeInstructionCoder.prototype.encodeState = function (_ixName, _ix) {
        throw new Error("Token Bridge program does not have state");
    };
    return TokenBridgeInstructionCoder;
}());
exports.TokenBridgeInstructionCoder = TokenBridgeInstructionCoder;
/** Solitaire enum of existing the Token Bridge's instructions.
 *
 * https://github.com/certusone/wormhole/blob/main/solana/modules/token_bridge/program/src/lib.rs#L100
 */
var TokenBridgeInstruction;
(function (TokenBridgeInstruction) {
    TokenBridgeInstruction[TokenBridgeInstruction["Initialize"] = 0] = "Initialize";
    TokenBridgeInstruction[TokenBridgeInstruction["AttestToken"] = 1] = "AttestToken";
    TokenBridgeInstruction[TokenBridgeInstruction["CompleteNative"] = 2] = "CompleteNative";
    TokenBridgeInstruction[TokenBridgeInstruction["CompleteWrapped"] = 3] = "CompleteWrapped";
    TokenBridgeInstruction[TokenBridgeInstruction["TransferWrapped"] = 4] = "TransferWrapped";
    TokenBridgeInstruction[TokenBridgeInstruction["TransferNative"] = 5] = "TransferNative";
    TokenBridgeInstruction[TokenBridgeInstruction["RegisterChain"] = 6] = "RegisterChain";
    TokenBridgeInstruction[TokenBridgeInstruction["CreateWrapped"] = 7] = "CreateWrapped";
    TokenBridgeInstruction[TokenBridgeInstruction["UpgradeContract"] = 8] = "UpgradeContract";
    TokenBridgeInstruction[TokenBridgeInstruction["CompleteNativeWithPayload"] = 9] = "CompleteNativeWithPayload";
    TokenBridgeInstruction[TokenBridgeInstruction["CompleteWrappedWithPayload"] = 10] = "CompleteWrappedWithPayload";
    TokenBridgeInstruction[TokenBridgeInstruction["TransferWrappedWithPayload"] = 11] = "TransferWrappedWithPayload";
    TokenBridgeInstruction[TokenBridgeInstruction["TransferNativeWithPayload"] = 12] = "TransferNativeWithPayload";
})(TokenBridgeInstruction = exports.TokenBridgeInstruction || (exports.TokenBridgeInstruction = {}));
function encodeTokenBridgeInstructionData(instructionType, data) {
    var dataLen = data === undefined ? 0 : data.length;
    var instructionData = Buffer.alloc(1 + dataLen);
    instructionData.writeUInt8(instructionType, 0);
    if (dataLen > 0) {
        instructionData.write(data.toString("hex"), 1, "hex");
    }
    return instructionData;
}
function encodeInitialize(_a) {
    var wormhole = _a.wormhole;
    var serialized = Buffer.alloc(32);
    serialized.write(new web3_js_1.PublicKey(wormhole).toBuffer().toString("hex"), 0, "hex");
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.Initialize, serialized);
}
function encodeAttestToken(_a) {
    var nonce = _a.nonce;
    var serialized = Buffer.alloc(4);
    serialized.writeUInt32LE(nonce, 0);
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.AttestToken, serialized);
}
function encodeCompleteNative(_a) {
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.CompleteNative);
}
function encodeCompleteWrapped(_a) {
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.CompleteWrapped);
}
function encodeTransferData(_a) {
    var nonce = _a.nonce, amount = _a.amount, fee = _a.fee, targetAddress = _a.targetAddress, targetChain = _a.targetChain;
    if (typeof amount != "bigint") {
        amount = BigInt(amount);
    }
    if (typeof fee != "bigint") {
        fee = BigInt(fee);
    }
    if (!Buffer.isBuffer(targetAddress)) {
        throw new Error("targetAddress must be Buffer");
    }
    var serialized = Buffer.alloc(54);
    serialized.writeUInt32LE(nonce, 0);
    serialized.writeBigUInt64LE(amount, 4);
    serialized.writeBigUInt64LE(fee, 12);
    serialized.write(targetAddress.toString("hex"), 20, "hex");
    serialized.writeUInt16LE(targetChain, 52);
    return serialized;
}
function encodeTransferWrapped(_a) {
    var nonce = _a.nonce, amount = _a.amount, fee = _a.fee, targetAddress = _a.targetAddress, targetChain = _a.targetChain;
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.TransferWrapped, encodeTransferData({ nonce: nonce, amount: amount, fee: fee, targetAddress: targetAddress, targetChain: targetChain }));
}
function encodeTransferNative(_a) {
    var nonce = _a.nonce, amount = _a.amount, fee = _a.fee, targetAddress = _a.targetAddress, targetChain = _a.targetChain;
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.TransferNative, encodeTransferData({ nonce: nonce, amount: amount, fee: fee, targetAddress: targetAddress, targetChain: targetChain }));
}
function encodeRegisterChain(_a) {
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.RegisterChain);
}
function encodeCreateWrapped(_a) {
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.CreateWrapped);
}
function encodeUpgradeContract(_a) {
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.UpgradeContract);
}
function encodeTransferWithPayloadData(_a) {
    var nonce = _a.nonce, amount = _a.amount, targetAddress = _a.targetAddress, targetChain = _a.targetChain, payload = _a.payload;
    if (typeof amount != "bigint") {
        amount = BigInt(amount);
    }
    if (!Buffer.isBuffer(targetAddress)) {
        throw new Error("targetAddress must be Buffer");
    }
    if (!Buffer.isBuffer(payload)) {
        throw new Error("payload must be Buffer");
    }
    var serializedWithPayloadLen = Buffer.alloc(50);
    serializedWithPayloadLen.writeUInt32LE(nonce, 0);
    serializedWithPayloadLen.writeBigUInt64LE(amount, 4);
    serializedWithPayloadLen.write(targetAddress.toString("hex"), 12, "hex");
    serializedWithPayloadLen.writeUInt16LE(targetChain, 44);
    serializedWithPayloadLen.writeUInt32LE(payload.length, 46);
    return Buffer.concat([
        serializedWithPayloadLen,
        payload,
        Buffer.alloc(1), // option == None
    ]);
}
function encodeTransferWrappedWithPayload(_a) {
    var nonce = _a.nonce, amount = _a.amount, fee = _a.fee, targetAddress = _a.targetAddress, targetChain = _a.targetChain, payload = _a.payload;
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.TransferWrappedWithPayload, encodeTransferWithPayloadData({
        nonce: nonce,
        amount: amount,
        fee: fee,
        targetAddress: targetAddress,
        targetChain: targetChain,
        payload: payload,
    }));
}
function encodeTransferNativeWithPayload(_a) {
    var nonce = _a.nonce, amount = _a.amount, fee = _a.fee, targetAddress = _a.targetAddress, targetChain = _a.targetChain, payload = _a.payload;
    return encodeTokenBridgeInstructionData(TokenBridgeInstruction.TransferNativeWithPayload, encodeTransferWithPayloadData({
        nonce: nonce,
        amount: amount,
        fee: fee,
        targetAddress: targetAddress,
        targetChain: targetChain,
        payload: payload,
    }));
}
