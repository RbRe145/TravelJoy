"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSequenceFromLogAptos = exports.parseSequenceFromLogNear = exports.parseSequenceFromLogAlgorand = exports.parseSequencesFromLogSolana = exports.parseSequenceFromLogSolana = exports.parseSequenceFromLogInjective = exports.parseSequencesFromLogTerra = exports.parseSequenceFromLogXpla = exports.parseSequenceFromLogTerra = exports.parseSequencesFromLogEth = exports.parseSequenceFromLogEth = void 0;
var ethers_1 = require("ethers");
var ethers_contracts_1 = require("../ethers-contracts");
function parseSequenceFromLogEth(receipt, bridgeAddress) {
    // TODO: dangerous!(?)
    var bridgeLog = receipt.logs.filter(function (l) {
        return l.address === bridgeAddress;
    })[0];
    var sequence = ethers_contracts_1.Implementation__factory.createInterface().parseLog(bridgeLog).args.sequence;
    return sequence.toString();
}
exports.parseSequenceFromLogEth = parseSequenceFromLogEth;
function parseSequencesFromLogEth(receipt, bridgeAddress) {
    // TODO: dangerous!(?)
    var bridgeLogs = receipt.logs.filter(function (l) {
        return l.address === bridgeAddress;
    });
    return bridgeLogs.map(function (bridgeLog) {
        var sequence = ethers_contracts_1.Implementation__factory.createInterface().parseLog(bridgeLog).args.sequence;
        return sequence.toString();
    });
}
exports.parseSequencesFromLogEth = parseSequencesFromLogEth;
function parseSequenceFromLogTerra(info) {
    // Scan for the Sequence attribute in all the outputs of the transaction.
    // TODO: Make this not horrible.
    var sequence = "";
    var jsonLog = JSON.parse(info.raw_log);
    jsonLog.map(function (row) {
        row.events.map(function (event) {
            event.attributes.map(function (attribute) {
                if (attribute.key === "message.sequence") {
                    sequence = attribute.value;
                }
            });
        });
    });
    return sequence.toString();
}
exports.parseSequenceFromLogTerra = parseSequenceFromLogTerra;
function parseSequenceFromLogXpla(info) {
    // Scan for the Sequence attribute in all the outputs of the transaction.
    // TODO: Make this not horrible.
    var sequence = "";
    var jsonLog = JSON.parse(info.raw_log);
    jsonLog.map(function (row) {
        row.events.map(function (event) {
            event.attributes.map(function (attribute) {
                if (attribute.key === "message.sequence") {
                    sequence = attribute.value;
                }
            });
        });
    });
    return sequence.toString();
}
exports.parseSequenceFromLogXpla = parseSequenceFromLogXpla;
function parseSequencesFromLogTerra(info) {
    // Scan for the Sequence attribute in all the outputs of the transaction.
    // TODO: Make this not horrible.
    var sequences = [];
    var jsonLog = JSON.parse(info.raw_log);
    jsonLog.map(function (row) {
        row.events.map(function (event) {
            event.attributes.map(function (attribute) {
                if (attribute.key === "message.sequence") {
                    sequences.push(attribute.value.toString());
                }
            });
        });
    });
    return sequences;
}
exports.parseSequencesFromLogTerra = parseSequencesFromLogTerra;
function parseSequenceFromLogInjective(info) {
    // Scan for the Sequence attribute in all the outputs of the transaction.
    var sequence = "";
    var jsonLog = JSON.parse(info.rawLog);
    jsonLog.map(function (row) {
        row.events.map(function (event) {
            event.attributes.map(function (attribute) {
                if (attribute.key === "message.sequence") {
                    sequence = attribute.value;
                }
            });
        });
    });
    return sequence.toString();
}
exports.parseSequenceFromLogInjective = parseSequenceFromLogInjective;
var SOLANA_SEQ_LOG = "Program log: Sequence: ";
function parseSequenceFromLogSolana(info) {
    var _a, _b, _c, _d;
    // TODO: better parsing, safer
    var sequence = (_d = (_c = (_b = (_a = info.meta) === null || _a === void 0 ? void 0 : _a.logMessages) === null || _b === void 0 ? void 0 : _b.filter(function (msg) { return msg.startsWith(SOLANA_SEQ_LOG); })) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.replace(SOLANA_SEQ_LOG, "");
    if (!sequence) {
        throw new Error("sequence not found");
    }
    return sequence.toString();
}
exports.parseSequenceFromLogSolana = parseSequenceFromLogSolana;
function parseSequencesFromLogSolana(info) {
    var _a, _b;
    // TODO: better parsing, safer
    return (_b = (_a = info.meta) === null || _a === void 0 ? void 0 : _a.logMessages) === null || _b === void 0 ? void 0 : _b.filter(function (msg) { return msg.startsWith(SOLANA_SEQ_LOG); }).map(function (msg) { return msg.replace(SOLANA_SEQ_LOG, ""); });
}
exports.parseSequencesFromLogSolana = parseSequencesFromLogSolana;
function parseSequenceFromLogAlgorand(result) {
    var sequence = "";
    if (result["inner-txns"]) {
        var innerTxns = result["inner-txns"];
        var iTxn = /** @class */ (function () {
            function iTxn() {
            }
            return iTxn;
        }());
        innerTxns.forEach(function (txn) {
            if (txn.logs) {
                sequence = ethers_1.BigNumber.from(txn.logs[0].slice(0, 8)).toString();
            }
        });
    }
    return sequence;
}
exports.parseSequenceFromLogAlgorand = parseSequenceFromLogAlgorand;
var NEAR_EVENT_PREFIX = "EVENT_JSON:";
function parseSequenceFromLogNear(outcome) {
    var e_1, _a, e_2, _b;
    try {
        for (var _c = __values(outcome.receipts_outcome), _d = _c.next(); !_d.done; _d = _c.next()) {
            var o = _d.value;
            try {
                for (var _e = (e_2 = void 0, __values(o.outcome.logs)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var l = _f.value;
                    if (l.startsWith(NEAR_EVENT_PREFIX)) {
                        var body = JSON.parse(l.slice(NEAR_EVENT_PREFIX.length));
                        if (body.standard === "wormhole" && body.event === "publish") {
                            return body.seq.toString();
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return null;
}
exports.parseSequenceFromLogNear = parseSequenceFromLogNear;
/**
 * Given a transaction result, return the first WormholeMessage event sequence
 * @param coreBridgeAddress Wormhole Core bridge address
 * @param result the result of client.waitForTransactionWithResult(txHash)
 * @returns sequence
 */
function parseSequenceFromLogAptos(coreBridgeAddress, result) {
    if (result.success) {
        var event_1 = result.events.find(function (e) { return e.type === coreBridgeAddress + "::state::WormholeMessage"; });
        return (event_1 === null || event_1 === void 0 ? void 0 : event_1.data.sequence) || null;
    }
    return null;
}
exports.parseSequenceFromLogAptos = parseSequenceFromLogAptos;
