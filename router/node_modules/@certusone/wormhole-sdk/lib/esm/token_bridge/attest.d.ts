import { Commitment, Connection, PublicKeyInitData, Transaction } from "@solana/web3.js";
import { MsgExecuteContract } from "@terra-money/terra.js";
import { MsgExecuteContractCompat as MsgExecuteContractInjective } from "@injectivelabs/sdk-ts";
import { Algodv2 } from "algosdk";
import { ethers, PayableOverrides } from "ethers";
import { TransactionSignerPair } from "../algorand";
import { ChainId } from "../utils";
import { Provider } from "near-api-js/lib/providers";
import { FunctionCallOptions } from "near-api-js/lib/account";
import { MsgExecuteContract as XplaMsgExecuteContract } from "@xpla/xpla.js";
import { Types } from "aptos";
export declare function attestFromEth(tokenBridgeAddress: string, signer: ethers.Signer, tokenAddress: string, overrides?: PayableOverrides & {
    from?: string | Promise<string>;
}): Promise<ethers.ContractReceipt>;
export declare function attestFromTerra(tokenBridgeAddress: string, walletAddress: string, asset: string): Promise<MsgExecuteContract>;
/**
 * Creates attestation message
 * @param tokenBridgeAddress Address of Inj token bridge contract
 * @param walletAddress Address of wallet in inj format
 * @param asset Name or address of the asset to be attested
 * For native assets the asset string is the denomination.
 * For foreign assets the asset string is the inj address of the foreign asset
 * @returns Message to be broadcast
 */
export declare function attestFromInjective(tokenBridgeAddress: string, walletAddress: string, asset: string): Promise<MsgExecuteContractInjective>;
export declare function attestFromXpla(tokenBridgeAddress: string, walletAddress: string, asset: string): XplaMsgExecuteContract;
export declare function attestFromSolana(connection: Connection, bridgeAddress: PublicKeyInitData, tokenBridgeAddress: PublicKeyInitData, payerAddress: PublicKeyInitData, mintAddress: PublicKeyInitData, commitment?: Commitment): Promise<Transaction>;
/**
 * Attest an already created asset
 * If you create a new asset on algorand and want to transfer it elsewhere,
 * you create an attestation for it on algorand... pass that vaa to the target chain..
 * submit it.. then you can transfer from algorand to that target chain
 * @param client An Algodv2 client
 * @param tokenBridgeId The ID of the token bridge
 * @param senderAcct The account paying fees
 * @param assetId The asset index
 * @returns Transaction ID
 */
export declare function attestFromAlgorand(client: Algodv2, tokenBridgeId: bigint, bridgeId: bigint, senderAddr: string, assetId: bigint): Promise<TransactionSignerPair[]>;
export declare function attestTokenFromNear(provider: Provider, coreBridge: string, tokenBridge: string, asset: string): Promise<FunctionCallOptions[]>;
export declare function attestNearFromNear(provider: Provider, coreBridge: string, tokenBridge: string): Promise<FunctionCallOptions>;
/**
 * Attest given token from Aptos.
 * @param tokenBridgeAddress Address of token bridge
 * @param tokenChain Origin chain ID
 * @param tokenAddress Address of token on origin chain
 * @returns Transaction payload
 */
export declare function attestFromAptos(tokenBridgeAddress: string, tokenChain: ChainId, tokenAddress: string): Types.EntryFunctionPayload;
