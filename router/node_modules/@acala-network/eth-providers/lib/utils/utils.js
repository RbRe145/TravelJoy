"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBN = exports.sortObjByKey = exports.isExtrinsicSuccessEvent = exports.isExtrinsicFailedEvent = exports.isTxFeeEvent = exports.isOrphanEvmEvent = exports.isNormalEvmEvent = exports.isEvmEvent = exports.isEvmExtrinsic = exports.checkEvmExecutionError = exports.decodeRevertMsg = exports.parseBlockTag = exports.ethToNativeDecimal = exports.nativeToEthDecimal = exports.runWithTiming = exports.getHealthResult = exports.runWithRetries = exports.promiseWithTimeout = exports.sleep = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const util_1 = require("@polkadot/util");
const bn_js_1 = __importDefault(require("bn.js"));
const sleep = (interval = 1000) => new Promise((resolve) => setTimeout(() => resolve(null), interval));
exports.sleep = sleep;
const promiseWithTimeout = (value, interval = 1000) => {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve) => {
        timeoutHandle = setTimeout(() => resolve(null), interval);
    });
    return Promise.race([value, timeoutPromise])
        .then((result) => {
        clearTimeout(timeoutHandle);
        return result;
    })
        .catch((error) => {
        clearTimeout(timeoutHandle);
        return Promise.reject(error);
    });
};
exports.promiseWithTimeout = promiseWithTimeout;
const runWithRetries = async (fn, args = [], maxRetries = 50, interval = 200) => {
    let res;
    let tries = 0;
    while (!res && tries++ < maxRetries) {
        res = await fn(...args);
        if (res) {
            return res;
        }
        else {
            if (tries === maxRetries)
                return res;
            if ((tries === 1 || tries % 10 === 0) && !res) {
                console.log(`<local mode runWithRetries> still waiting for result # ${tries}/${maxRetries}`);
            }
            await (0, exports.sleep)(interval);
        }
    }
    return res;
};
exports.runWithRetries = runWithRetries;
const getHealthResult = ({ indexerMeta, cacheInfo, curFinalizedHeight, ethCallTiming, listenersCount, }) => {
    const MAX_IDLE_TIME = 30 * 60; // half an hour
    const MAX_IDLE_BLOCKS = 50; // ~10 minutes
    const ETH_CALL_MAX_TIME = 5000; // 5 seconds
    let isHealthy = true;
    let isSubqlOK = true;
    let isCacheOK = true;
    let isRPCOK = true;
    const msg = [];
    /* --------------- cache --------------- */
    const maxCachedBlocks = cacheInfo?.maxCachedBlocks || 0;
    let cachedBlocksCount = 0;
    if (!cacheInfo) {
        msg.push('no cache running!');
        isHealthy = false;
        isCacheOK = false;
    }
    else {
        cachedBlocksCount = cacheInfo.cachedBlocksCount;
        // only care if at least 1000
        if (cachedBlocksCount > Math.max(1000, Math.floor(maxCachedBlocks * 1.3))) {
            msg.push(`cached blocks size is bigger than expected: ${cachedBlocksCount}, expect at most ~${maxCachedBlocks}`);
            isHealthy = false;
            isCacheOK = false;
        }
    }
    /* --------------- subql --------------- */
    // lastProcessedTimestamp seems to be delayed for a little bit, but it's OK
    const lastProcessedTimestamp = parseInt(indexerMeta?.lastProcessedTimestamp || '0');
    const lastProcessedHeight = indexerMeta?.lastProcessedHeight || 0;
    const targetHeight = indexerMeta?.targetHeight || 0;
    const indexerHealthy = indexerMeta?.indexerHealthy || false;
    const curTimestamp = Date.now();
    const idleTime = (curTimestamp - lastProcessedTimestamp) / 1000;
    const idleBlocks = curFinalizedHeight - Number(lastProcessedHeight);
    if (!indexerMeta) {
        msg.push('no indexer is running!');
        isHealthy = false;
        isSubqlOK = false;
    }
    else {
        if (idleTime > MAX_IDLE_TIME) {
            const idleMinutes = Math.floor(idleTime / 60);
            const idleHours = (idleTime / 3600).toFixed(1);
            msg.push(`indexer already idle for: ${idleTime} seconds = ${idleMinutes} minutes = ${idleHours} hours`);
            isHealthy = false;
            isSubqlOK = false;
        }
        if (idleBlocks > MAX_IDLE_BLOCKS) {
            msg.push(`indexer already idle for: ${idleBlocks} blocks`);
            isHealthy = false;
            isSubqlOK = false;
        }
        if (idleBlocks < -MAX_IDLE_BLOCKS) {
            msg.push(`node production already idle for: ${-idleBlocks} blocks`);
            isHealthy = false;
        }
    }
    /* --------------- RPC --------------- */
    Object.values(ethCallTiming).forEach((t) => {
        if (t > ETH_CALL_MAX_TIME) {
            msg.push(`an RPC is getting slow, takes more than ${ETH_CALL_MAX_TIME / 1000} seconds to complete internally. All timings: ${JSON.stringify(ethCallTiming)}`);
            isHealthy = false;
            isRPCOK = false;
        }
        if (t === -1) {
            msg.push(`an RPC is getting running errors. All timings: ${JSON.stringify(ethCallTiming)}`);
            isHealthy = false;
            isRPCOK = false;
        }
        if (t === -999) {
            msg.push(`an RPC is getting timeouts. All timings: ${JSON.stringify(ethCallTiming)}`);
            isHealthy = false;
            isRPCOK = false;
        }
    });
    /* --------------- result --------------- */
    return {
        isHealthy,
        isSubqlOK,
        isCacheOK,
        isRPCOK,
        msg,
        moreInfo: {
            // cache
            cachedBlocksCount,
            maxCachedBlocksCount: maxCachedBlocks,
            // subql
            lastProcessedHeight,
            targetHeight,
            curFinalizedHeight,
            lastProcessedTimestamp,
            curTimestamp,
            idleSeconds: idleTime,
            idleBlocks,
            indexerHealthy,
            // RPC
            ethCallTiming,
            // listeners
            // TODO: currently only print out info, no threshold check
            listenersCount,
        },
    };
};
exports.getHealthResult = getHealthResult;
const TIME_OUT = 20000; // 20s
const runWithTiming = async (fn, repeats = 3) => {
    let res = null;
    const t0 = performance.now();
    let runningErr = false;
    let timedout = false;
    try {
        for (let i = 0; i < repeats; i++) {
            res = await (0, exports.promiseWithTimeout)(fn(), TIME_OUT);
            // fn should always return something
            if (res === null) {
                res = `error in runWithTiming: timeout after ${TIME_OUT / 1000} seconds`;
                timedout = true;
                break;
            }
        }
    }
    catch (e) {
        res = `error in runWithTiming: ${e.toString()}`;
        runningErr = true;
    }
    const t1 = performance.now();
    const time = runningErr ? -1 : timedout ? -999 : (t1 - t0) / repeats;
    return {
        res,
        time,
    };
};
exports.runWithTiming = runWithTiming;
const ETH_DECIMALS = 18;
const NATIVE_DECIMALS = 12;
const nativeToEthDecimal = (value) => bignumber_1.BigNumber.from(value).mul(10 ** (ETH_DECIMALS - NATIVE_DECIMALS));
exports.nativeToEthDecimal = nativeToEthDecimal;
const ethToNativeDecimal = (value) => bignumber_1.BigNumber.from(value).div(10 ** (ETH_DECIMALS - NATIVE_DECIMALS));
exports.ethToNativeDecimal = ethToNativeDecimal;
const parseBlockTag = async (_blockTag) => {
    const blockTag = await _blockTag;
    if (!blockTag || typeof blockTag !== 'object')
        return blockTag;
    return blockTag['blockHash'] || blockTag['blockNumber'];
};
exports.parseBlockTag = parseBlockTag;
// https://github.com/AcalaNetwork/Acala/blob/067b65bc19ff525bdccae020ad2bd4bdf41f4300/modules/evm/rpc/src/lib.rs#L122
const decodeRevertMsg = (hexMsg) => {
    const data = (0, util_1.hexToU8a)(hexMsg);
    const msgStart = 68;
    if (data.length <= msgStart)
        return '';
    const msgLength = bignumber_1.BigNumber.from(data.slice(36, msgStart));
    const msgEnd = msgStart + msgLength.toNumber();
    if (data.length < msgEnd)
        return '';
    const body = data.slice(msgStart, msgEnd);
    return new TextDecoder('utf-8').decode(body);
};
exports.decodeRevertMsg = decodeRevertMsg;
// https://github.com/AcalaNetwork/Acala/blob/067b65bc19ff525bdccae020ad2bd4bdf41f4300/modules/evm/rpc/src/lib.rs#L87
const checkEvmExecutionError = (data) => {
    if (!data)
        return;
    const { exit_reason: exitReason, value: returnData } = data;
    if (!exitReason.succeed) {
        let msg;
        let err;
        if (exitReason.revert) {
            msg = (0, exports.decodeRevertMsg)(returnData);
            err = new Error(`execution reverted: ${msg}`);
            err.data = returnData;
        }
        else if (exitReason.fatal) {
            msg = JSON.stringify(exitReason.fatal);
            err = new Error(`execution fatal: ${msg}`);
        }
        else if (exitReason.error) {
            const reason = Object.keys(exitReason.error)[0];
            msg = reason === 'other' ? exitReason.error[reason] : reason;
            err = new Error(`execution error: ${msg}`);
        }
        else {
            err = new Error('unknown eth call error');
        }
        err.code = -32603;
        throw err;
    }
};
exports.checkEvmExecutionError = checkEvmExecutionError;
const isEvmExtrinsic = (e) => e.method.section.toLowerCase() === 'evm';
exports.isEvmExtrinsic = isEvmExtrinsic;
const isEvmEvent = (e) => e.event.section.toLowerCase() === 'evm' &&
    ['Created', 'Executed', 'CreatedFailed', 'ExecutedFailed'].includes(e.event.method);
exports.isEvmEvent = isEvmEvent;
const isNormalEvmEvent = (event) => (0, exports.isEvmEvent)(event) && event.phase.isApplyExtrinsic;
exports.isNormalEvmEvent = isNormalEvmEvent;
const isOrphanEvmEvent = (event) => (0, exports.isEvmEvent)(event) && !event.phase.isApplyExtrinsic;
exports.isOrphanEvmEvent = isOrphanEvmEvent;
const isTxFeeEvent = (event) => event.event.section.toUpperCase() === 'TRANSACTIONPAYMENT' && event.event.method === 'TransactionFeePaid';
exports.isTxFeeEvent = isTxFeeEvent;
const isExtrinsicFailedEvent = (event) => event.event.method === 'ExtrinsicFailed';
exports.isExtrinsicFailedEvent = isExtrinsicFailedEvent;
const isExtrinsicSuccessEvent = (event) => event.event.method === 'ExtrinsicSuccess';
exports.isExtrinsicSuccessEvent = isExtrinsicSuccessEvent;
const sortObjByKey = (key) => (a, b) => !a[key]
    ? -1
    : typeof a[key] === 'string'
        ? a[key].localeCompare(b[key])
        : a[key] - b[key];
exports.sortObjByKey = sortObjByKey;
const toBN = (bigNumberis = 0) => {
    if ((0, util_1.isU8a)(bigNumberis)) {
        return (0, util_1.u8aToBn)(bigNumberis);
    }
    if ((0, util_1.isHex)(bigNumberis)) {
        return (0, util_1.hexToBn)(bigNumberis);
    }
    if (bignumber_1.BigNumber.isBigNumber(bigNumberis)) {
        const hex = bigNumberis.toHexString();
        if (hex[0] === '-') {
            return new bn_js_1.default('-' + hex.substring(3), 16);
        }
        return new bn_js_1.default(hex.substring(2), 16);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new bn_js_1.default(bigNumberis);
};
exports.toBN = toBN;
