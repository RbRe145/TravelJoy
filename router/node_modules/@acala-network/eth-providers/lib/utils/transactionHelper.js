"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeGasLimit = exports.getTransactionRequest = exports.calcSubstrateTransactionParams = exports.calcEthereumTransactionParams = void 0;
const ethers_1 = require("ethers");
const properties_1 = require("@ethersproject/properties");
const consts_1 = require("../consts");
const transactions_1 = require("@ethersproject/transactions");
const receiptHelper_1 = require("./receiptHelper");
const bytes_1 = require("@ethersproject/bytes");
const divRoundUp = (x, y) => {
    const mod = x.mod(y);
    const div = x.div(y);
    return div.add(mod.gt(0) ? 1 : 0);
};
const calcEthereumTransactionParams = (data) => {
    const gasLimit = ethers_1.BigNumber.from(data.gasLimit);
    const storageLimit = ethers_1.BigNumber.from(data.storageLimit);
    const validUntil = ethers_1.BigNumber.from(data.validUntil);
    const storageByteDeposit = ethers_1.BigNumber.from(data.storageByteDeposit);
    const txFeePerGas = ethers_1.BigNumber.from(data.txFeePerGas);
    const blockPeriod = divRoundUp(validUntil, ethers_1.BigNumber.from(30));
    const storageEntryLimit = divRoundUp(storageLimit, ethers_1.BigNumber.from(64));
    const storageEntryDeposit = storageByteDeposit.mul(64);
    const txGasPrice = txFeePerGas.add(blockPeriod.shl(16)).add(storageEntryLimit);
    const txGasLimit = storageEntryDeposit.div(txFeePerGas).mul(storageEntryLimit).add(gasLimit);
    return {
        txGasPrice,
        txGasLimit,
    };
};
exports.calcEthereumTransactionParams = calcEthereumTransactionParams;
const calcSubstrateTransactionParams = (data) => {
    const txGasPrice = ethers_1.BigNumber.from(data.txGasPrice);
    const txGasLimit = ethers_1.BigNumber.from(data.txGasLimit);
    const storageByteDeposit = ethers_1.BigNumber.from(data.storageByteDeposit);
    const txFeePerGas = ethers_1.BigNumber.from(data.txFeePerGas);
    const storageEntryLimit = txGasPrice.and(0xffff);
    const blockPeriod = txGasPrice.sub(storageEntryLimit).sub(txFeePerGas).shr(16);
    const storageLimit = storageEntryLimit.mul(64);
    const validUntil = blockPeriod.mul(30);
    const storageEntryDeposit = storageByteDeposit.mul(64);
    const gasLimit = txGasLimit.sub(storageEntryDeposit.div(txFeePerGas).mul(storageEntryLimit));
    return {
        gasLimit,
        storageLimit,
        validUntil,
    };
};
exports.calcSubstrateTransactionParams = calcSubstrateTransactionParams;
const getTransactionRequest = async (transaction) => {
    const values = await transaction;
    const tx = {};
    ['from', 'to'].forEach((key) => {
        if (values[key] === null || values[key] === undefined) {
            return;
        }
        tx[key] = Promise.resolve(values[key]).then((v) => (v ? v : null));
    });
    ['gasLimit', 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas', 'value'].forEach((key) => {
        if (values[key] === null || values[key] === undefined) {
            return;
        }
        tx[key] = Promise.resolve(values[key]).then((v) => (v ? ethers_1.BigNumber.from(v) : null));
    });
    ['type'].forEach((key) => {
        if (values[key] === null || values[key] === undefined) {
            return;
        }
        tx[key] = Promise.resolve(values[key]).then((v) => (v !== null || v !== undefined ? v : null));
    });
    if (values.accessList) {
        tx.accessList = (0, transactions_1.accessListify)(values.accessList);
    }
    ['data'].forEach((key) => {
        if (values[key] === null || values[key] === undefined) {
            return;
        }
        tx[key] = Promise.resolve(values[key]).then((v) => (v ? (0, bytes_1.hexlify)(v) : null));
    });
    return receiptHelper_1.formatter.transactionRequest(await (0, properties_1.resolveProperties)(tx));
};
exports.getTransactionRequest = getTransactionRequest;
const encodeGasLimit = (txFee, gasPrice, gasLimit, usedStorage, isTokenTransfer = false) => {
    const rawEthGasLimit = txFee.div(gasPrice);
    const encodedStorageLimit = usedStorage.gt(0)
        ? Math.ceil(Math.log2(usedStorage.toNumber()))
        : 0;
    let encodedGasLimit = gasLimit.div(consts_1.GAS_LIMIT_CHUNK).add(1);
    if (isTokenTransfer) {
        // for token transfer, need to make sure when metamask 1.5X gasLimit, it won't affect cc
        // bbb => b(b+1)0
        encodedGasLimit = encodedGasLimit.div(10).add(1).mul(10);
    }
    const aaaa00000 = rawEthGasLimit.gt(consts_1.GAS_MASK)
        ? rawEthGasLimit.div(consts_1.GAS_MASK).mul(consts_1.GAS_MASK)
        : ethers_1.BigNumber.from(consts_1.GAS_MASK);
    const bbb00 = encodedGasLimit.mul(consts_1.STORAGE_MASK);
    const cc = encodedStorageLimit;
    return aaaa00000.add(bbb00).add(cc); // aaaabbbcc
};
exports.encodeGasLimit = encodeGasLimit;
