"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseReceiptsFromBlockData = exports.getAllReceiptsAtBlock = void 0;
const consts_1 = require("../consts");
const ethers_1 = require("ethers");
const providers_1 = require("@ethersproject/providers");
const receiptHelper_1 = require("./receiptHelper");
const utils_1 = require("./utils");
const getAllReceiptsAtBlock = async (api, blockHash, targetTxHash) => {
    const apiAtTargetBlock = await api.at(blockHash);
    const [block, blockEvents] = await Promise.all([
        api.rpc.chain.getBlock(blockHash),
        apiAtTargetBlock.query.system.events(),
    ]);
    return (0, exports.parseReceiptsFromBlockData)(api, block, blockEvents, targetTxHash);
};
exports.getAllReceiptsAtBlock = getAllReceiptsAtBlock;
const parseReceiptsFromBlockData = async (api, block, blockEvents, targetTxHash) => {
    const { header } = block.block;
    const blockNumber = header.number.toNumber();
    const blockHash = header.hash.toHex();
    const _apiAtParentBlock = api.at(header.parentHash); // don't wait here in case not being used
    let normalTxs = block.block.extrinsics
        .map((extrinsic, idx) => ({
        extrinsic,
        extrinsicEvents: extractTargetEvents(blockEvents, idx),
    }))
        .filter(({ extrinsicEvents }) => (extrinsicEvents.some(utils_1.isNormalEvmEvent) &&
        !extrinsicEvents.find(utils_1.isExtrinsicFailedEvent)));
    if (targetTxHash) {
        normalTxs = normalTxs.filter(({ extrinsic }) => extrinsic.hash.toHex() === targetTxHash);
    }
    const normalReceiptsPending = normalTxs.map(async ({ extrinsicEvents, extrinsic }, transactionIndex) => {
        const evmEvent = (0, receiptHelper_1.findEvmEvent)(extrinsicEvents);
        if (!evmEvent) {
            throw new Error(`cannot find evmEvent: ${JSON.stringify(extrinsicEvents)}`);
        }
        const isErc20Xcm = extrinsic.method.method.toString() === 'setValidationData';
        const effectiveGasPrice = isErc20Xcm
            ? consts_1.BIGNUMBER_ZERO
            : await getEffectiveGasPrice(api, _apiAtParentBlock, extrinsic, extrinsicEvents, evmEvent);
        const transactionHash = extrinsic.hash.toHex();
        const txInfo = { transactionIndex, blockHash, transactionHash, blockNumber };
        const partialReceipt = (0, receiptHelper_1.getPartialTransactionReceipt)(evmEvent);
        const logs = partialReceipt.logs.map((log) => ({
            ...txInfo,
            ...log,
        }));
        return providers_1.Formatter.check(receiptHelper_1.fullReceiptFormatter, {
            effectiveGasPrice,
            ...txInfo,
            ...partialReceipt,
            logs,
        });
    });
    const normalReceipts = await Promise.all(normalReceiptsPending);
    const orphanReceipts = (0, receiptHelper_1.getOrphanTxReceiptsFromEvents)(blockEvents, blockHash, blockNumber, normalReceipts.length);
    const allCandidateReceipts = [...normalReceipts, ...orphanReceipts];
    return targetTxHash
        ? allCandidateReceipts.filter((r) => r.transactionHash === targetTxHash)
        : allCandidateReceipts;
};
exports.parseReceiptsFromBlockData = parseReceiptsFromBlockData;
const extractTargetEvents = (allEvents, targetIdx) => allEvents.filter(event => (event.phase.isApplyExtrinsic &&
    event.phase.asApplyExtrinsic.toNumber() === targetIdx));
const getEffectiveGasPrice = async (api, _apiAtParentBlock, extrinsic, extrinsicEvents, evmEvent) => {
    let nativeTxFee;
    const txFeeEvent = extrinsicEvents.find(utils_1.isTxFeeEvent);
    if (txFeeEvent) {
        // [who, actualFee, actualTip, actualSurplus]
        nativeTxFee = ethers_1.BigNumber.from(txFeeEvent.event.data[1].toString());
    }
    else {
        const u8a = extrinsic.toU8a();
        const apiAtParentBlock = await _apiAtParentBlock;
        const successEvent = extrinsicEvents.find(utils_1.isExtrinsicSuccessEvent);
        if (!successEvent) {
            throw new Error(`cannot find extrinsic success event: ${JSON.stringify(extrinsicEvents)}`);
        }
        const dispatchInfo = successEvent.event.data[0];
        const actualWeight = dispatchInfo.weight.refTime ??
            dispatchInfo.weight;
        const [paymentInfo, feeDetails] = await Promise.all([
            apiAtParentBlock.call.transactionPaymentApi.queryInfo(u8a, u8a.length),
            apiAtParentBlock.call.transactionPaymentApi.queryFeeDetails(u8a, u8a.length),
        ]);
        const estimatedWeight = paymentInfo.weight?.refTime ??
            paymentInfo.weight;
        const { baseFee, lenFee, adjustedWeightFee } = feeDetails.inclusionFee.unwrap();
        const weightFee = (adjustedWeightFee.toBigInt() * actualWeight.toBigInt()) / estimatedWeight.toBigInt();
        nativeTxFee = ethers_1.BigNumber.from(baseFee.toBigInt() + lenFee.toBigInt() + weightFee);
    }
    let txFee = (0, utils_1.nativeToEthDecimal)(nativeTxFee);
    const eventData = evmEvent.event.data;
    const usedGas = ethers_1.BigNumber.from(eventData[eventData.length - 2].toString());
    const usedStorage = ethers_1.BigNumber.from(eventData[eventData.length - 1].toString());
    if (usedGas.eq(0))
        return ethers_1.BigNumber.from(consts_1.ONE_HUNDRED_GWEI);
    if (usedStorage.gt(0)) {
        // ignore storage refund (usedStorage < 0) since it might result in negative gas
        const storageDepositPerByte = api.consts.evm.storageDepositPerByte.toBigInt();
        const storageFee = usedStorage.mul(storageDepositPerByte);
        txFee = txFee.add(storageFee);
    }
    return txFee.div(usedGas);
};
