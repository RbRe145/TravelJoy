import { Provider as AbstractProvider, Block, BlockTag, BlockWithTransactions, EventType, FeeData, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from '@ethersproject/abstract-provider';
import { AcalaEvmTX } from '@acala-network/eth-transactions';
import { AccessList } from 'ethers/lib/utils';
import { Header } from '@polkadot/types/interfaces';
import { ApiPromise } from '@polkadot/api';
import { BigNumber, BigNumberish } from 'ethers';
import { Deferrable } from '@ethersproject/properties';
import { EvmAccountInfo, EvmContractInfo } from '@acala-network/types/interfaces';
import { Formatter } from '@ethersproject/providers';
import { Network } from '@ethersproject/networks';
import { Observable, ReplaySubject } from 'rxjs';
import { Option } from '@polkadot/types';
import { Storage } from '@polkadot/types/metadata/decorate/types';
import { SubmittableExtrinsic } from '@polkadot/api/types';
import { VersionedRegistry } from '@polkadot/api/base/types';
import LRUCache from 'lru-cache';
import { BaseLogFilter, FullReceipt, HealthResult, LogFilter, SanitizedLogFilter } from './utils';
import { BlockCache, CacheInspect } from './utils/BlockCache';
import { ISubmittableResult } from '@polkadot/types/types';
import { MaxSizeSet } from './utils/MaxSizeSet';
import { SubqlProvider } from './utils/subqlProvider';
import { _Metadata } from './utils/gqlTypes';
export declare type Eip1898BlockTag = {
    blockNumber: string | number;
} | {
    blockHash: string;
};
export declare type Signature = 'Ethereum' | 'AcalaEip712' | 'Substrate';
export interface BlockData {
    hash: `0x${string}`;
    parentHash: `0x${string}`;
    number: number;
    stateRoot: `0x${string}`;
    transactionsRoot: `0x${string}`;
    timestamp: number;
    nonce: `0x${string}`;
    mixHash: `0x${string}`;
    difficulty: number;
    totalDifficulty: number;
    gasLimit: BigNumber;
    gasUsed: BigNumber;
    miner: string;
    extraData: `0x${string}`;
    sha3Uncles: `0x${string}`;
    receiptsRoot: `0x${string}`;
    logsBloom: `0x${string}`;
    size: number;
    uncles: string[];
    transactions: `0x${string}`[] | TX[];
}
export declare type Numberish = bigint | string | number;
export interface SubstrateEvmCallRequest {
    from?: string;
    to?: string;
    gasLimit?: Numberish;
    storageLimit?: Numberish;
    value?: Numberish;
    data?: string;
    accessList?: AccessList;
}
export interface partialTX {
    from: string;
    to: string | null;
    blockHash: string | null;
    blockNumber: number | null;
    transactionIndex: number | null;
}
export interface TX extends partialTX {
    hash: string;
    nonce: number;
    value: BigNumberish;
    gasPrice: BigNumberish;
    gas: BigNumberish;
    input: string;
    v: string;
    r: string;
    s: string;
}
export interface TXReceipt extends partialTX {
    contractAddress: string | null;
    root?: string;
    gasUsed: BigNumber;
    logsBloom: string;
    transactionHash: string;
    logs: Array<Log>;
    cumulativeGasUsed: BigNumber;
    effectiveGasPrice: BigNumber;
    type: number;
    status?: number;
}
export interface GasConsts {
    storageDepositPerByte: bigint;
    txFeePerGas: bigint;
}
export interface EventData {
    [index: string]: {
        weight: {
            refTime: number;
            proofSize: number;
        };
        class: string;
        paysFee: string;
    };
}
export interface BaseProviderOptions {
    safeMode?: boolean;
    localMode?: boolean;
    verbose?: boolean;
    subqlUrl?: string;
    maxBlockCacheSize?: number;
    storageCacheSize?: number;
    healthCheckBlockDistance?: number;
}
export declare type BlockTagish = BlockTag | Promise<BlockTag> | undefined;
export declare enum SubscriptionType {
    NewHeads = "newHeads",
    NewFinalizedHeads = "newFinalizedHeads",
    Logs = "logs"
}
export interface BlockListener {
    id: string;
    cb: (data: any) => void;
}
export interface LogListener extends BlockListener {
    filter: BaseLogFilter;
}
export interface EventListeners {
    [SubscriptionType.NewHeads]: BlockListener[];
    [SubscriptionType.NewFinalizedHeads]: BlockListener[];
    [SubscriptionType.Logs]: LogListener[];
}
export declare enum PollFilterType {
    NewBlocks = "newBlocks",
    Logs = "logs"
}
export interface BlockPollFilter {
    id: string;
    lastPollBlockNumber: number;
    lastPollTimestamp: number;
}
export interface LogPollFilter extends BlockPollFilter {
    logFilter: LogFilter;
}
export interface PollFilters {
    [PollFilterType.NewBlocks]: BlockPollFilter[];
    [PollFilterType.Logs]: LogPollFilter[];
}
export interface CallInfo {
    ok?: {
        exit_reason: {
            succeed?: 'Stopped' | 'Returned' | 'Suicided';
            error?: any;
            revert?: 'Reverted';
            fatal?: any;
        };
        value: string;
        used_gas: number;
        used_storage: number;
        logs: Log[];
    };
    err?: {
        module: {
            index: number;
            error: `0x${string}`;
        };
    };
}
export declare abstract class BaseProvider extends AbstractProvider {
    #private;
    readonly _api?: ApiPromise;
    readonly subql?: SubqlProvider;
    readonly formatter: Formatter;
    readonly eventListeners: EventListeners;
    readonly pollFilters: PollFilters;
    readonly safeMode: boolean;
    readonly localMode: boolean;
    readonly verbose: boolean;
    readonly maxBlockCacheSize: number;
    readonly storages: WeakMap<VersionedRegistry<'promise'>, Storage>;
    readonly storageCache: LRUCache<string, Uint8Array | null>;
    readonly blockCache: BlockCache;
    readonly finalizedBlockHashes: MaxSizeSet;
    network?: Network | Promise<Network>;
    head$: Observable<Header>;
    finalizedHead$: Observable<Header>;
    best$: ReplaySubject<{
        hash: string;
        number: number;
    }>;
    finalized$: ReplaySubject<{
        hash: string;
        number: number;
    }>;
    constructor({ safeMode, localMode, verbose, maxBlockCacheSize, storageCacheSize, subqlUrl, }?: BaseProviderOptions);
    get bestBlockHash(): Promise<string>;
    get bestBlockNumber(): Promise<number>;
    get finalizedBlockHash(): Promise<string>;
    get finalizedBlockNumber(): Promise<number>;
    static isProvider(value: any): value is Provider;
    startSubscriptions: () => Promise<() => void>;
    _onNewHead: ([header, attempts]: [Header, number]) => Promise<void>;
    _onNewFinalizedHead: ([header, attempts]: [Header, number]) => Promise<void>;
    _notifySubscribers: (header: Header, receipts: FullReceipt[]) => Promise<void>;
    setApi: (api: ApiPromise) => void;
    queryStorage: <T = any>(module: `${string}.${string}`, args: any[], _blockTag?: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<T>;
    get api(): ApiPromise;
    get genesisHash(): string;
    get isConnected(): boolean;
    get chainDecimal(): number;
    get isSafeMode(): boolean;
    isReady: () => Promise<void>;
    disconnect: () => Promise<void>;
    getNetwork: () => Promise<Network>;
    netVersion: () => Promise<string>;
    chainId: () => Promise<number>;
    getBlockNumber: () => Promise<number>;
    getBlockData: (_blockTag: BlockTag | Promise<BlockTag>, full?: boolean) => Promise<BlockData>;
    getBlockDataForHeader: (header: Header, full?: boolean) => Promise<BlockData>;
    getBlock: (_blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>) => Promise<Block>;
    getBlockWithTransactions: (_blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>) => Promise<BlockWithTransactions>;
    getBalance: (addressOrName: string | Promise<string>, _blockTag?: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<BigNumber>;
    getTransactionCount: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<number>;
    getEvmTransactionCount: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>) => Promise<number>;
    getSubstrateNonce: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>) => Promise<number>;
    getCode: (addressOrName: string | Promise<string>, _blockTag?: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<string>;
    call: (_transaction: Deferrable<TransactionRequest>, _blockTag?: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<string>;
    _ethCall: (callRequest: SubstrateEvmCallRequest, at?: string) => Promise<{
        exit_reason: {
            succeed?: "Stopped" | "Returned" | "Suicided";
            error?: any;
            revert?: "Reverted";
            fatal?: any;
        };
        value: string;
        used_gas: number;
        used_storage: number;
        logs: Log[];
    }>;
    getStorageAt: (addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, _blockTag?: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<string>;
    resolveName: (name: string | Promise<string>) => Promise<string>;
    getGasPrice: (validBlocks?: number) => Promise<BigNumber>;
    getFeeData: () => Promise<FeeData>;
    _getGasConsts: () => GasConsts;
    /**
     * Estimate gas for a transaction.
     * @param transaction The transaction to estimate the gas of
     * @returns The estimated gas used by this transaction
     */
    estimateGas: (transaction: Deferrable<TransactionRequest>) => Promise<BigNumber>;
    _estimateGasCost: (extrinsic: SubmittableExtrinsic<'promise', ISubmittableResult>) => Promise<BigNumber>;
    /**
     * Get the gas for eth transactions
     * @returns The gas used by eth transaction
     */
    getEthResources: (transaction: Deferrable<TransactionRequest>, { gasLimit, storageLimit, validUntil, }?: {
        gasLimit?: BigNumberish;
        storageLimit?: BigNumberish;
        validUntil?: BigNumberish;
    }) => Promise<{
        gasPrice: BigNumber;
        gasLimit: BigNumber;
    }>;
    /**
     * helper to get ETH gas when don't know the whole transaction
     * default to return big enough gas for contract deployment
     * @returns The gas used by eth transaction
     */
    _getEthGas: ({ gasLimit, storageLimit, validUntil: _validUntil, }?: {
        gasLimit?: BigNumberish;
        storageLimit?: BigNumberish;
        validUntil?: BigNumberish;
    }) => Promise<{
        gasPrice: BigNumber;
        gasLimit: BigNumber;
    }>;
    /**
     * Validate substrate transaction parameters
     */
    validSubstrateResources: ({ gasLimit, gasPrice, }: {
        gasLimit: BigNumberish;
        gasPrice: BigNumberish;
    }) => {
        gasLimit: BigNumber;
        storageLimit: BigNumber;
        validUntil: BigNumber;
    };
    /**
     * Estimate resources for a transaction.
     * @param transaction The transaction to estimate the resources of
     * @returns The estimated resources used by this transaction
     */
    estimateResources: (transaction: Deferrable<TransactionRequest>) => Promise<{
        usedGas: BigNumber;
        gasLimit: BigNumber;
        usedStorage: BigNumber;
    }>;
    getSubstrateAddress: (addressOrName: string, blockTag?: BlockTag | Promise<BlockTag>) => Promise<string>;
    getEvmAddress: (substrateAddress: string, blockTag?: BlockTag | Promise<BlockTag>) => Promise<string>;
    queryAccountInfo: (addressOrName: string | Promise<string>, _blockTag?: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<Option<EvmAccountInfo>>;
    queryContractInfo: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>) => Promise<Option<EvmContractInfo>>;
    _getSubstrateGasParams: (ethTx: Partial<AcalaEvmTX>) => {
        gasLimit: bigint;
        storageLimit: bigint;
        validUntil: bigint;
        tip: bigint;
        accessList: AccessList;
        v2: boolean;
    };
    prepareTransaction: (rawTx: string) => Promise<{
        extrinsic: SubmittableExtrinsic<'promise'>;
        transaction: AcalaEvmTX;
    }>;
    sendRawTransaction: (rawTx: string) => Promise<string>;
    sendTransaction: (signedTransaction: string | Promise<string>) => Promise<TransactionResponse>;
    _wrapTransaction: (tx: AcalaEvmTX, hash: string, startBlock: number, startBlockHash: string) => Promise<TransactionResponse>;
    _getBlockNumber: (blockTag: BlockTag) => Promise<number>;
    _getBlockHash: (_blockTag?: BlockTag | Promise<BlockTag>) => Promise<string>;
    _isBlockCanonical: (blockHash: string, _blockNumber?: number) => Promise<boolean>;
    _isBlockFinalized: (blockTag: BlockTag) => Promise<boolean>;
    _isTransactionFinalized: (txHash: string) => Promise<boolean>;
    _ensureSafeModeBlockTagFinalization: (_blockTag: BlockTagish) => Promise<BlockTagish>;
    _getBlockHeader: (blockTag?: BlockTag | Promise<BlockTag>) => Promise<Header>;
    _getAddress: (addressOrName: string | Promise<string>) => Promise<string>;
    getReceiptAtBlockFromChain: (txHash: string | Promise<string>, _blockTag: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<TransactionReceipt | null>;
    getReceiptAtBlock: (hashOrNumber: number | string | Promise<string>, _blockTag: BlockTag | Promise<BlockTag> | Eip1898BlockTag) => Promise<TransactionReceipt | null>;
    _getReceiptAtBlockByHash: (txHash: string, blockHash: string) => Promise<TransactionReceipt>;
    _getReceiptAtBlockByIndex: (txIdx: number | string, blockHash: string) => Promise<FullReceipt>;
    _getPendingTX: (txHash: string) => Promise<TX | null>;
    getTransaction: (_txHash: string) => Promise<TransactionResponse>;
    getTransactionByHash: (txHash: string) => Promise<TX | null>;
    getTransactionReceipt: (_txHash: string) => Promise<TransactionReceipt>;
    getReceipt: (txHash: string) => Promise<TransactionReceipt | null>;
    _getReceipt: (txHash: string) => Promise<TransactionReceipt | null>;
    _sanitizeRawFilter: (rawFilter: LogFilter) => Promise<SanitizedLogFilter>;
    getLogs: (rawFilter: LogFilter) => Promise<Log[]>;
    _waitForSubql: (_targetBlock: number) => Promise<never>;
    getIndexerMetadata: () => Promise<_Metadata | undefined>;
    getCachInfo: () => CacheInspect | undefined;
    _timeEthCalls: () => Promise<{
        gasPriceTime: number;
        estimateGasTime: number;
        getBlockTime: number;
        getFullBlockTime: number;
    }>;
    healthCheck: () => Promise<HealthResult>;
    lookupAddress: (_address: string | Promise<string>) => Promise<string>;
    waitForTransaction: (_transactionHash: string, _confirmations?: number, _timeout?: number) => Promise<TransactionReceipt>;
    addEventListener: (eventName: string, listener: Listener, filter?: any) => string;
    removeEventListener: (id: string) => boolean;
    addPollFilter: (filterType: string, logFilter?: any) => Promise<string>;
    _pollLogs: (filterInfo: LogPollFilter) => Promise<Log[]>;
    _pollBlocks: (filterInfo: BlockPollFilter) => Promise<string[]>;
    poll: (id: string, logsOnly?: boolean) => Promise<string[] | Log[]>;
    removePollFilter: (id: string) => boolean;
    on: (_eventName: EventType, _listener: Listener) => Provider;
    once: (_eventName: EventType, _listener: Listener) => Provider;
    emit: (_eventName: EventType, ..._args: Array<any>) => boolean;
    listenerCount: (_eventName?: EventType) => number;
    listeners: (_eventName?: EventType) => Array<Listener>;
    off: (_eventName: EventType, _listener?: Listener) => Provider;
    removeAllListeners: (_eventName?: EventType) => Provider;
}
